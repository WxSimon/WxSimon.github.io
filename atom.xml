<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Simon</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://simonxin.top/"/>
  <updated>2018-06-03T12:05:40.135Z</updated>
  <id>http://simonxin.top/</id>
  
  <author>
    <name>Simon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>服务器迁移小计</title>
    <link href="http://simonxin.top/2018/06/03/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%81%E7%A7%BB%E5%B0%8F%E8%AE%A1/"/>
    <id>http://simonxin.top/2018/06/03/服务器迁移小计/</id>
    <published>2018-06-03T02:33:00.000Z</published>
    <updated>2018-06-03T12:05:40.135Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>哇.一晃一年过去了,看自己上篇博客还是去年九月份的时候更新了，唉！回想起自己秋招之后的这半年,感觉真的是可以用命运多舛来形容了,好在日子会越过越好,现在的工作虽然没有武汉时那么清闲,偶尔会加班到十一二点,但是年轻人嘛,或者就是折腾得。刚好撑着这个周末其它的一些事情都处理结束了,查看自己的阿里云也马上到期了,(😔 毕业就薅不到这些羊毛了)。但是服务器上还部署着很多服务,所以想着刚好写写自己最近的状态和把服务器上的东西备份一下。</p></blockquote><a id="more"></a><h2 id="服务器迁移"><a href="#服务器迁移" class="headerlink" title="服务器迁移"></a>服务器迁移</h2><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><ul><li><p>1.去Java官网下载相关的Jdk开发环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -c --header &quot;Cookie: oraclelicense=accept-securebackup-cookie&quot; http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><ul><li>1.编辑相关环境变量<code>vim /etc/profile</code></li><li><p>2.添加环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   export JAVA_HOME=/usr/java/jdk1.8.0_144</span><br><span class="line">export JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">export CLASSPATH=./:$JAVA_HOME/lib:$JAVA_HOM/jre/lib</span><br></pre></td></tr></table></figure></li><li><p>3.执行<code>source /etc/profile</code></p></li><li><p>4.验证<code>java -version</code></p><p>到这里Java的开发环境就安装好了,很简单有木有。</p></li></ul></li></ul><h4 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h4><p>作为一个Java开发者,怎么可能少的了Mysql呢,但是现在由于云技术的发展,安装mysql可以采用两种方式,下面具体介绍</p><ul><li><p>普通安装方式(不推荐)</p><p>1.可以去Mysql的官网下载相关依赖库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm</span><br></pre></td></tr></table></figure><p>2.使用仓库安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install mysql-server</span><br></pre></td></tr></table></figure><p>3.mysql的一些基本命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mysqld #启动MySQL</span><br><span class="line">systemctl stop mysqld #关闭MySQL</span><br><span class="line">systemctl restart mysqld #重启MySQL</span><br><span class="line">systemctl status mysqld #查看MySQL运行状态</span><br><span class="line">systemctl enable mysqld #设置开机启动</span><br><span class="line">systemctl disable mysqld #关闭开机启动</span><br></pre></td></tr></table></figure><p>4.找到临时密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &apos;temporary password&apos; /var/log/mysqld.log</span><br></pre></td></tr></table></figure><p>5.删除密码安全限制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNINSTALL PLUGIN validate_password;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>到这里普通的Mysql安装方式也结束了,那么来看看Doker是如何安装的把</strong></p></blockquote><ul><li><p>采用Docker安装</p><ul><li><p>1.首先得安装Docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install docker-io</span><br></pre></td></tr></table></figure></li><li><p>2.找到一个可靠的源(这里推荐DaoCloud的源)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://hub.daocloud.io/</span><br></pre></td></tr></table></figure></li><li><p>3.配置Mysql的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mysql -e MYSQL_ROOT_PASSWORD=xxx -p 3306:3306 -d daocloud.io/mysql:tag</span><br></pre></td></tr></table></figure><ul><li>其中<code>MYSQL_ROOT_PASSWORD</code>后加mysql的密码</li><li><code>-p</code>后加需要映射的端口</li></ul></li><li><p>4.安装进行后<br>我们就存在一个默认的容器,使用<code>docker ps</code>就可以看到列表</p></li><li><p>5.如何进入容器<br><code>docker exec -it xxx /bash/bin</code></p><p><strong>到这里Mysql Docker的安装方式也结束了</strong></p></li></ul></li></ul><h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><p>Nginx是现在比较主流的一款web服务器,但是在Linux上，nginx的安装方式还是很麻烦的,所以有Docker的情况下,我们没比较再去花时间在安装上面，我们可以直接去镜像中心下载nginx的镜像</p><ul><li><p>编写自己的Dockerfile</p><ul><li>1.创建相关的文件夹<br><code>mkdir -p ~/nginx/www ~/nginx/logs ~/nginx/conf</code>三个文件夹的含义分别为:<ul><li>www目录将映射为nginx容器配置的虚拟目录</li><li>logs目录将映射为nginx容器的日志目录</li><li>conf目录里的配置文件将映射为nginx容器的配置文件</li></ul></li><li><p>2.拉取Nginx镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure></li><li><p>3.运行镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80:80 --name mynginx -v $PWD/www:/www -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf -v $PWD/logs:/wwwlogs  -d nginx  xxx</span><br></pre></td></tr></table></figure><ul><li><p>-p 80:80：将容器的80端口映射到主机的80端口</p></li><li><p>–name mynginx：将容器命名为mynginx</p></li><li><p>-v $PWD/www:/www：将主机中当前目录下的www挂载到容器的/www</p></li><li><p>-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf：将主机中当前目录下的nginx.conf挂载到容器的/etc/nginx/nginx.conf</p></li><li><p>-v $PWD/logs:/wwwlogs：将主机中当前目录下的logs挂载到容器的/wwwlogs</p></li></ul></li></ul></li></ul><h3 id="服务程序"><a href="#服务程序" class="headerlink" title="服务程序"></a>服务程序</h3><blockquote><p>现在在服务器上还存在的程序有:<a href="http://simoncode.top/movie" target="_blank" rel="noopener">80s的电影爬虫</a>,<a href="http://simoncode.top" target="_blank" rel="noopener">个人主页</a>;</p></blockquote><h4 id="电影爬虫"><a href="#电影爬虫" class="headerlink" title="电影爬虫"></a>电影爬虫</h4><p>这个项目是采用SpringBoot+Redis实现的,其实编写的时间还算挺早的,早在17年九月份在武汉实习的时候花了不到一个星期就完成了,之后就一直部署在自己的服务器上，期间还自己重构过几次,但是由于天生并不是编写前端的料子,所及虽然重构过几次,页面依然是非常的丑.这个爬虫采用SpringBoot编写,所以只需要有Java环境就可以运行,但是里面相关依赖了Redis、Mysql等组件,所以运行的话需要先将这个组件安装.</p><ul><li><p>自动化更新脚本:</p><p>  凭借自己对Linux的一知半解,编写了一个脚本,用来自动化从Git上拉取代码和更新打包运行。脚本主要分三部分:</p><p> 运行脚本(run.sh):</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java  -jar  -Dserver.port=8089  xxx-1.0-SNAPSHOT.jar   &amp;&gt;nohup.out &amp;</span><br></pre></td></tr></table></figure><p> 停止脚本(stop.sh):</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   for PID in `ps aux | grep &apos;java&apos; | grep &apos;movie&apos; | grep -v &apos;grep&apos; | awk &apos;&#123;print $2&#125;&apos;`; do</span><br><span class="line">        kill -9 $PID</span><br><span class="line">done</span><br><span class="line">echo &quot;[kill Simon service]&quot;</span><br></pre></td></tr></table></figure><p> 更新脚本(update.sh):</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd ~/source/Zhihu #源码路径</span><br><span class="line">git pull #更新代码</span><br><span class="line">mvn package -Dmaven.test.skip=true #maven打包</span><br><span class="line">cd ~/zhihu#进入项目目录</span><br><span class="line">sh stop.sh </span><br><span class="line">rm -f web-1.0.0-SNAPSHOT.jar</span><br><span class="line">mv ~/source/Zhihu/web/target/web-1.0-SNAPSHOT.jar ~/zhihu</span><br><span class="line">echo Project Update Finish </span><br><span class="line">sh run.sh</span><br><span class="line">echo Project Running</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>使用上部分自动化脚本的前提是你得配置了github的相关ssh key<br>其实配置github的相关key 也是很简单的,只需要在bash中输入<code>ssh-keygen -t rsa -C &quot;email&quot;</code>就可以了</p></blockquote><h4 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h4><ul><li>其中程序的主要代码都托管在github上了,需要备份的主要是sql数据。sql数据中有两部分:1.就是爬取的电影的sql 2.就是毕业设计做的爬取知乎的sql。</li></ul><h2 id="学习总结"><a href="#学习总结" class="headerlink" title="学习总结"></a>学习总结</h2><p>😔,今天都已经是六月3号了,2018年都已经过半了,这个月中旬,我的身份也要从大学生变成了一名社会人了,虽然当初在学校的时候，由于各种原因,自己一直迫切着想要去工作,但是当想想自己马上就要离开校园,再也回不去的时候,还是有一点点感伤的。再想想自己的2017年后半年,一点新鲜的技术都没有学习到,用的东西和了解的东西也都过于局限。</p><h2 id="New-Life"><a href="#New-Life" class="headerlink" title="New Life"></a>New Life</h2><blockquote><p>既然是自己的博客,那么久可以畅所欲言和记录自己琐碎的事情.</p></blockquote><p>4.16日,毕业答辩。虽然距离现在马上要到两个月了,但是那天或者说那个星期的事情我都依然清楚的记得。那天早上六点多我就醒来,收拾收拾后便和邹恒一起打的前往火车站,我们是九点半的车但是我们七点多就到了火车站,等了两个多小时,当我们提着行李到铁轨旁后车时。我俩都感觉自己度过了滑稽可笑的三个月,三个月里面知识没长、见识没长、钱包没长。我俩商量着接下来的打算,他准备去深证我准备…经过一天的“长途跋涉”，终于到了学校,哇 看到同学回到宿舍的那一刻真的好幸福,顿时感觉自己还是一个学生,什么压力都没有。五点多到宿舍,和同学交流了一会,便去和张鹏赴约,感觉和张鹏总是有聊不完的话题,可能都是对技术的喜欢,就像我和邹恒一样,总是有聊不完的技术和问题,[虽然大部分时间都是他在和我讲着我从来都没有听说过的技术]。见到老哥的那一刻依然是那么的情切,还没来得及聊聊最近的状况他便去见他的导师了。唉约好的去一次上海都没有实现。</p><p>第二天,也就是答辩的那天,七点多我本来还在床上睡觉呢,室友便说他程序有bug🤣叫我去帮忙修bug，带着困意和疲惫。我去了。没想到的是我尽然在哪里呆了一天😂也就是我帮他们修了一天的bug。和同学们聊天感觉真的很开心！但是由于自身的原因，第二天晚上便离开了学校。后面的事情就让它过去吧。</p><p><strong>讲讲现在吧</strong><br>也不知道是命运还是啥,本来信心满满的小杨并没有考上自己准备一年的志愿者。带着失落的她也投身到了找工作的行列,有时候命运就是那么意想不到,从大一开始就准备工作的我到上个月才能说是真正的开始工作,而一直以为会继续读书的她既然也开始了工作，好在彼此都比较勤奋和努力,虽然比不上那些大佬,但是和暂时的自己比起来还是算不差的。</p><p>她在南京找到了一份还不错的工作，福利待遇行业都比较符合她的口味,就这样我们寄去年七月份后又再一次的在一起了,也算结束了四年的异地恋.每天下班早或者周末的时候都可以做一顿好吃的一起品尝。[话说现在的我做饭手艺确实不赖啊!]</p><p>最后分享一点最近的照片吧.</p><p><img src="/images/18.6.3/01.JPG" alt="酷酷的小杨"></p><center><font color="grey"><strong>酷酷的小杨</strong></font></center><br><img src="/images/18.6.3/02.JPG" alt="安静的小杨"><br><br><br><img src="/images/18.6.3/03.JPG" alt="安静的小杨"><br><br><br><img src="/images/18.6.3/04.JPG" alt="酷酷的小杨"><br><br><br><img src="/images/18.6.3/05.JPG" alt="酷酷的小杨"><br><br><br><img src="/images/18.6.3/06.JPG" alt="酷酷的小杨"><br><br><br><img src="/images/18.6.3/07.JPG" alt="酷酷的小杨"><br><br><br><img src="/images/18.6.3/08.JPG" alt="酷酷的小杨"><br><center><font color="grey"><strong>安静的小杨</strong></font></center><br><img src="/images/18.6.3/09.JPG" alt="快要死掉的多肉"><br><center><font color="grey"><strong>快要死掉的多肉</strong></font></center>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;哇.一晃一年过去了,看自己上篇博客还是去年九月份的时候更新了，唉！回想起自己秋招之后的这半年,感觉真的是可以用命运多舛来形容了,好在日子会越过越好,现在的工作虽然没有武汉时那么清闲,偶尔会加班到十一二点,但是年轻人嘛,或者就是折腾得。刚好撑着这个周末其它的一些事情都处理结束了,查看自己的阿里云也马上到期了,(😔 毕业就薅不到这些羊毛了)。但是服务器上还部署着很多服务,所以想着刚好写写自己最近的状态和把服务器上的东西备份一下。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术" scheme="http://simonxin.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="总结" scheme="http://simonxin.top/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="Linux" scheme="http://simonxin.top/tags/Linux/"/>
    
      <category term="云服务" scheme="http://simonxin.top/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Docker" scheme="http://simonxin.top/tags/Docker/"/>
    
      <category term="工作" scheme="http://simonxin.top/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>实习总结</title>
    <link href="http://simonxin.top/2017/09/03/%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://simonxin.top/2017/09/03/实习总结/</id>
    <published>2017-09-03T10:16:33.000Z</published>
    <updated>2018-06-02T10:39:15.759Z</updated>
    
    <content type="html"><![CDATA[<p>17.7.3-17.9.3 刚好两个月的时间，我觉得我有必要对我的第一次实习做一次总结了。<br><a id="more"></a></p><h2 id="从第一天说起"><a href="#从第一天说起" class="headerlink" title="从第一天说起"></a>从第一天说起</h2><p>6.30号，因为前天晚上我和室友们一起开放打麻将，早上起来的一场大雨真的是一点面子也没给，我们四个冒着大雨从宾馆冲回了宿舍，因为所有的东西都基本收拾差不多了，我们拿到行李箱之后便向接我们的大巴走去。四个人，三个人去一个地方，而另外一个去其他地方的就是我。庆幸的是我们乘坐的是同一辆车，伴随这忽大忽小的雨我们到达了武汉，一到武汉我感觉我整个人呢愈发的抗拒起来，我抗拒的并不是这座城市，而是马上要去的培训机构。我讨厌去哪里学习一些我丝毫不感兴趣的东西，我讨厌学校的领导把我们当作他们的赚钱工具。好在，我是幸运的，我能够逃离那个地方去另外一个地方继续学习我喜欢的知识。然而那天也发生了很多插曲，比如我害怕纯纯等的太久就自己离开了集合的地方而被班主任简单的批评了一顿。因为不得不面对，和社会上的人商量租房。拖着巨大的行李箱住进了这座我陌生的城市。</p><h2 id="两个月中"><a href="#两个月中" class="headerlink" title="两个月中"></a>两个月中</h2><p>当第一天在公司上完班之后，觉得之前心里的恐惧少了几分。取而代之的是对这座城市的适应，物价和咸宁的区别，生活方式和学校的区别，这些都在慢慢的适应。觉得那些干吧的话我也不知道怎么说了，下面我就从技术方面对自己总结一下。<br>掌握/了解到新的技术栈:</p><ul><li>SpringBoot</li><li>Redis</li><li>Hbase</li><li>Vue</li><li>前端</li><li>ELK</li><li>分布式服务</li><li>Nginx</li><li>Maven<br>上面这些我所列举都是我在学校没有听过或者听过从来没有实践过的，但是在这两个月里，我每天都是和这些技术一起。给我最直观的区别就是学校学习的东西和外面用到的东西区别是真的大。我们学校还是在用三大框架，各种xml配置，而学习了SPringBoot之后我觉得这个框架真的大大的减轻了开发的成本。而因为boss的要求，我一个前端小白，也硬着头皮把一个前端项目迁移成为Vue项目。迁移过程中我了解到不少前端的知识，包括WebPack 和jQuery BootStapt 。。。 附上一个我准备详细整理我学习的技术栈的链接戳我<h2 id="之后"><a href="#之后" class="headerlink" title="之后"></a>之后</h2>这次去了之后，打算好好的整理整理自己的简历，秋招我来了！！！</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;17.7.3-17.9.3 刚好两个月的时间，我觉得我有必要对我的第一次实习做一次总结了。&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="http://simonxin.top/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="http://simonxin.top/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="生活" scheme="http://simonxin.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="技术" scheme="http://simonxin.top/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>技术小计</title>
    <link href="http://simonxin.top/2017/09/02/%E6%8A%80%E6%9C%AF%E5%B0%8F%E8%AE%A1/"/>
    <id>http://simonxin.top/2017/09/02/技术小计/</id>
    <published>2017-09-02T07:49:14.000Z</published>
    <updated>2018-06-02T10:13:45.169Z</updated>
    
    <content type="html"><![CDATA[<h2 id="技术小计"><a href="#技术小计" class="headerlink" title="技术小计"></a>技术小计</h2><blockquote><p> 写在前面，这篇博客的目的主要是总结我在公司实习的这两个月里面所接触的一些新技术栈，因为时间的关系今天就只能跟新我自己弄的ELK监控平台，以后肯定会慢慢把我这两个月学习的补充上去。</p></blockquote><a id="more"></a><h3 id="ELK-日志监控平台"><a href="#ELK-日志监控平台" class="headerlink" title="ELK 日志监控平台"></a>ELK 日志监控平台</h3><blockquote><p> 缘起: 因为实习公司的主要业务就是爬虫,所以所有的服务都是以分布式的方式存在。所以公司就使用ELK搭建了一个日志监控平台。</p></blockquote><p>首先ELK看似是存在三个服务的，就我简单理解。分别为:</p><ul><li>Elasticsearch 处理格式化日志</li><li>Logstash 收集日志</li><li>Kinaba 前台展示</li></ul><p>那我现在就一一讲一下我搭建这个平台的时候碰到的坑。首先这三个服务的所有下载包都可以到Elk下载。</p><h4 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h4><ul><li><p>下载安装包<br><code>wget https://artifacts.elasticco/downloads/elasticsearch/elasticsearch-5.5.2.zip</code></p><ul><li>使用非root用户登陆</li><li>因为Elasticsearch的安全策略，禁止root用户启动，所以需要创建一个非root用户来运行Elasticsearch程序。<code>useradd simon</code></li><li>更换Elasticsearh的工作目录的所有者和组都为<code>simon</code>所有。</li></ul></li><li>修改配置文件<ul><li>开启服务之前还会遇到一个坑，就是Elasticsearch默认的内存为2g而一般的服务器都不会得到那么大的内存，所以需要到<code>/config/log4j2.properties</code> 修改内存为能顾接受的范围。</li></ul></li><li>运行<br>好了到这里Elasticsearch的配置就差不多了,只需要让它默默的跑在后台给我们处理日志就可以了。<code>nohup ./bin/elasticsearch &gt;&amp; nohup.out &amp;</code></li><li>验证<br>如何看自己的Elasticsearch是否真的运行在后台呢？<br>只需要访问Elasticsearch的服务测试一下就可以<code>curl localhost:9200</code></li></ul><h3 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h3><ul><li><p>下载安装包<br><code>wget https://artifacts.elastic.co/downloads/logstash/logstash-5.5.2.tar.gz  tar -zxvf</code></p></li><li><p>创建输入输出模板<br>前面说过我的浅显理解Logstas就是用来对日志的收集，所以必定存在对日志输入和输出设定。我这里使用的log4j的日志输入，而且Logstash存在log4j的模板，所以我的日志设置为(需要自建文件):<br><code>Set: https://www.elastic.co/guide/en/logstash/current/configuration-file-structure.htmlinput {For detail config for log4j as input,See: https://www.elastic.co/guide/en/logstash/current/plugins-inputs-log4j.htmllog4j {  mode =&gt; &quot;server&quot;  host =&gt; &quot;0.0.0.0&quot;  port =&gt; 4500}}filter {Only matched data are send to output.}output {For detail config for elasticsearch as output,See: https://www.elastic.co/guide/en/logstash/current/plugins-outputs-elasticsearch.htmlelasticsearch {  action =&gt; &quot;index&quot;          #The operation on ES  hosts  =&gt; &quot;localhost:9200&quot;   #ElasticSearch host, can be array.  index  =&gt; &quot;applog&quot;         #The index to write data to.}}</code></p></li></ul><p>其中各个参数的含义如下:</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">类型</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">mode</td><td style="text-align:center">server/client</td><td style="text-align:center">服务器/客户端</td></tr><tr><td style="text-align:center">host</td><td style="text-align:center">string</td><td style="text-align:center">服务地址</td></tr><tr><td style="text-align:center">port</td><td style="text-align:center">int</td><td style="text-align:center">服务端口</td></tr><tr><td style="text-align:center">antion</td><td style="text-align:center">index</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">hosts</td><td style="text-align:center">string</td><td style="text-align:center">服务的地址</td></tr><tr><td style="text-align:center">index</td><td style="text-align:center">Stirng</td><td style="text-align:center">parent 的名称</td></tr></tbody></table><p>其中，加入你是把你的ELK放在服务器端的话，就需要把hosy设置成为允许访问的ip即 0.0.0.0</p><ul><li>SpringBoot日志输送</li></ul><p>由于SpringBoot的成熟，所以已经集成了Logstash的日志传输服务，只需要在application.properties中添加:</p><p><code>log4j.appender.logstash=org.apache.log4j.net.SocketAppenderlog4j.appender.logstash.RemoteHost=your_server_hostlog4j.appender.logstash.port=4500log4j.appender.logstash.ReconnectionDelay=60000log4j.appender.logstash.LocationInfo=true</code></p><p>当然你事先得导入log4j的maven依赖库</p><p>`</p><p><dependency><br>  <groupid>org.slf4j</groupid><br>         <artifactid>slf4j-log4j12</artifactid><br></dependency><br>`</p><ul><li>运行</li></ul><p>当一切准备结束之后，我们就可以让Logstash也默默热运行在后台了<br><code>nohup ./bin/logstash -f log4j.conf *&amp; nohup.out &amp;</code></p><h3 id="Kinaba"><a href="#Kinaba" class="headerlink" title="Kinaba"></a>Kinaba</h3><p>下载安装包<br><code>wget https://artifacts.elastic.co/downloads/kibana/kibana-5.5.2-linux-x86_64.tar.gztar -zxvf</code></p><ul><li>配置Kinaba允许外网访问</li></ul><p>进入Kinaba的<code>config/</code>目录下vi Kinaba.yml<br>其中将:</p><ul><li>server.port ：port</li><li>server.host :0.0.0.0</li><li>elasticsearch.url: “<a href="http://localhost:9200“" target="_blank" rel="noopener">http://localhost:9200“</a></li></ul><p>设置完毕，看起来Kinaba的设置相比前面起来简单很多。</p><ul><li>运行</li></ul><p>啦啦啦，只需要简单的配置Kinaba的服务可以运行起来了。<br><code>nohup Kinaba &gt;&amp; nohup.out &amp;</code></p><ul><li>测试</li></ul><p>我们可以打开浏览器输入: localhost:port，等一会，我们就可以看到Kinaba的界面了。<br>然后在中我们在配置Logstash设置的index属性：applog，然后我们就可以看到我们的日志文件了。</p><p><strong>最后说一下，三个的服务启动时存在先后顺序的，处理日志的Elasticsearch必须第一个启动，原因是Logstash中设置了文件输出的位置，假设Elasticsearch的服务没有启动的话，就会存在找不到输出文件的错误。同理在Knaba中也设置了读取日志文件的位置。</strong></p><p>好了，到这里一个简单的日志监控平台就搭建完毕了，因为我写的这篇博客完全都是出于个人的理解，所以其中个肯定存在很多问题。仅供参考。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;技术小计&quot;&gt;&lt;a href=&quot;#技术小计&quot; class=&quot;headerlink&quot; title=&quot;技术小计&quot;&gt;&lt;/a&gt;技术小计&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 写在前面，这篇博客的目的主要是总结我在公司实习的这两个月里面所接触的一些新技术栈，因为时间的关系今天就只能跟新我自己弄的ELK监控平台，以后肯定会慢慢把我这两个月学习的补充上去。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="总结" scheme="http://simonxin.top/categories/%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>最近的总结</title>
    <link href="http://simonxin.top/2017/05/08/%E6%9C%80%E8%BF%91%E7%8A%B6%E6%80%81%E6%80%BB%E7%BB%93/"/>
    <id>http://simonxin.top/2017/05/08/最近状态总结/</id>
    <published>2017-05-08T12:46:16.000Z</published>
    <updated>2017-05-08T11:15:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>先来一张我最喜欢的照片</strong><br><img src="/images/17.5.8/那些年我们二十七八岁.jpg" alt=""></p><blockquote><p>写在前面:晚上解决一个算法问题，解决了一晚上但是并没有解决^_^，所以趁着现在还没有回去的时间对自己最近的生活学习状况进行一个总结。</p></blockquote><a id="more"></a><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><h3 id="课堂"><a href="#课堂" class="headerlink" title="课堂"></a>课堂</h3><p>  说到上课，愈发的觉得自己成为老油条了。大一的时候上课带书又带笔有时候还带草稿本，大二带书带笔，大三沦落到要考试了都不知道带笔去上课。。好在这个学期的考试课很少，大部分的考察课都是可以蒙混过关的。其实说道上课，我就不得不说一下我们BT的学校，上课收手机，院长动不动就冲进来这种事情真的没想到在读大学的我身上发生了，真的无语。讲道理，院里面这样抓我们的学习，应该是很放心我们的就业的，但是动不动就以名曰“就业指导”的口号叫我们去各种培训机构的宣讲会。看来对赚钱的事情果然每个人都是很上心的。说实话虽然在我的心目中是很抵触培训机构的，因为要是去培训结构的话什么不直接不读大学就去呢？非要在大学耽误那么长时间。但是我也不否认培训结构对一些大学没学习(讲道理我也啥都没学到)什么的是一条路子。但是为什么我觉得是屎的东西院里面还要用力往每个人嘴里面喂。。搞不懂搞不懂。。</p><h3 id="实验室"><a href="#实验室" class="headerlink" title="实验室"></a>实验室</h3><ul><li>看完了小甲鱼关于数据结构的视频</li><li>看完了《剑指Offer》</li><li>参加了春招的笔试(心痛自己)</li><li>参与了实验室的一点小项目</li><li><p>复习了Java的很多小基础知识</p><p>一本《剑指Offer》开学的时候买的，到今天才算是真真的搞完了(虽然保存到了github,因为都是一些平常学习的代码，所以将仓库私有了，主要还是怕丑^_^)。说实话虽然是看完了，只能说自己以后看到这种编程题目的时候不会再那么畏惧，但是好多思路还是不知道从哪里来。虽然有时候看的也不是很认真，但是毕竟是过了一遍的。发自内心的觉得算法这个东西很强大。关于看完数据结构的C语言版视频虽然也花了很长时间，但是只能说是是加深了其中的某些印象，比如树的结构，二叉树的便利，链表,队列…看过的还是知道一点的。再说说关于春招，觉得还是自己的态度没有摆端正，算法问题一点都不知道，所以做每个公司的编程题目的时候都不知道从何下手，很多问题都是没有听说过，其中关于哈夫曼树和背包问题我花了一下午的时候进行了详细的总结。觉得也算是自己的一点成就吧。既然春招没有用心准备，那就把所有的心思都放在秋招上面咯。只有祝自己好运咯。</p></li></ul><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p><img src="/images/17.5.8/graduation_photo_1.jpg" alt=""><br><img src="/images/17.5.8/graduation_photo_2.jpg" alt=""><br>  上个星期四拍完的毕业照，我们院有着个让人不能理解的传统，每届都是在大三的时候拍毕业照。可惜我那天并没有把头发梳成大人模样，哈哈… 现在还记得我们上一届拍毕业照的时候，那天我刚好在实验室，他们抱着一大堆学士服，没想到一转眼就轮到我穿上了。。(话说那天还被他们草柱子了)<strong>现在这里立一个flag：大四毕业的时候一定要喝醉。。</strong>感觉之前的日子有点想不起来了。。(尴尬)<br>    最后再说说和纯纯的事情吧(感觉很少把这种事情写成文字发出来):纯纯现在下定目标准备出国读研了，这就意味着她也是要面临这毕业就就业的问题了。我内心从大一的时候就有这种打算所以对我来说还好，我就怕纯纯到时候有点不能接受。好了这个事情就不扯了。虽说我们两个这个学期也是有点小问题不断，而且我都总结出规律来了(都是星期五的！！！),但是还是坚持下来了，对我来说，在一起之前我都不知道什么叫做”异地恋”,感觉稀里糊涂的就开始了这段恋情。而且稀里糊涂得一起过了这么久，有时候自己想想都觉得有点不可思议。。感觉这个学期结束之前应该没有机会去她哪里了。说起来惭愧大学到现在三年了，去过他们学校的次数真的可以用手指头数出来。。<br>    最后的最后就来说一下去郑州的过程吧。虽然去之前我们还闹着矛盾，原本准备星期五见面的我冲动的买了当天的票，火车上坐了一晚上都是想着见面时候的喜悦。越想越激动，想着待会纯纯见到我的时候的喜悦，坐公交的时候感觉自己都想一到就冲下去的那种。果然所有异地恋都一样，一见面什么问题多解决了。哈哈，还来了一个少林寺一日游。开心。！！<strong>我不知道未来怎么样，我只想好好的过好现在的每一天</strong><br>  最后的最后来几张照片吧。。 哈哈<br><img src="/images/17.5.8/chunchun1.jpg" alt=""><br><img src="/images/17.5.8/chunchun2.jpg" alt=""><br><img src="/images/17.5.8/chunchun3.jpg" alt=""><br><img src="/images/17.5.8/chunchun4.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;先来一张我最喜欢的照片&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;/images/17.5.8/那些年我们二十七八岁.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;写在前面:晚上解决一个算法问题，解决了一晚上但是并没有解决^_^，所以趁着现在还没有回去的时间对自己最近的生活学习状况进行一个总结。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="总结" scheme="http://simonxin.top/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="http://simonxin.top/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>详细了解哈夫曼树和背包问题</title>
    <link href="http://simonxin.top/2017/04/12/%E8%AF%A6%E7%BB%86%E4%BA%86%E8%A7%A3%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%92%8C%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://simonxin.top/2017/04/12/详细了解哈夫曼树和背包问题/</id>
    <published>2017-04-12T06:47:16.000Z</published>
    <updated>2017-05-08T11:15:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="详细了解哈夫曼树和背包问题"><a href="#详细了解哈夫曼树和背包问题" class="headerlink" title="详细了解哈夫曼树和背包问题"></a>详细了解哈夫曼树和背包问题</h1><p><b>写在前面</b>：</p><ul><li>最近在疯狂复习数据结构和算法，虽然看完了一部完整的视频。但是转眼看看自己手中的《剑指Offer》里面还是不是很清楚。。。而且最近也突然觉得自己知识和别人比起来就是一个渣渣。各种被人家吊打。。。</li><li><b>这两个算法一个（哈夫曼树）是看最近视频动手实践的，一个(背包问题)是前段时间一个面试里面的题目，当时不知道这是一个系类的问题，昨天和大神聊完天之后才明白。所以乘着短暂的热情还在就记录下来</b>先从哈夫曼树开始！！<a id="more"></a></li></ul><h3 id="1-哈夫曼树（实现基本的编码解码）"><a href="#1-哈夫曼树（实现基本的编码解码）" class="headerlink" title="1.哈夫曼树（实现基本的编码解码）"></a>1.哈夫曼树（实现基本的编码解码）</h3><ul><li><p>简单定义：<br>   给定n个权值作为n个叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p><p>  复杂的文字定义我觉得以后肯定不会看。。所以直接来一张哈夫曼树的构造过程简单明了。。<br>  <img src="/images/17.4.11/huffmanTree.jpg" alt=""></p></li></ul><h4 id="1-模型构造"><a href="#1-模型构造" class="headerlink" title="1.模型构造"></a>1.模型构造</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节点类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line">String data;</span><br><span class="line"><span class="keyword">double</span> weight;</span><br><span class="line">Node leftChild;</span><br><span class="line">Node rightChild;</span><br><span class="line">Node parent;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeftChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> parent != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span> == parent.leftChild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String data, <span class="keyword">double</span> weight)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.data = data;</span><br><span class="line"><span class="keyword">this</span>.weight = weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Node [data="</span> + data + <span class="string">", weight="</span> + weight + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队列排序依据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>) (weight - o.weight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeaf</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> data.length() == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包含属性:<br>| 属性 | 定义 | 类型 |<br>| —– | —– |  —- |<br>| data | 数据 | String |<br>| weight | 权值 | double |<br>| leftChild | 左节点 | Node |<br>| rightChild | 右节点 | Node |<br>| parent | 父节点 | Node |</p><h4 id="2-统计字符出现的次数，用出现的次数作为权值"><a href="#2-统计字符出现的次数，用出现的次数作为权值" class="headerlink" title="2.统计字符出现的次数，用出现的次数作为权值"></a>2.统计字符出现的次数，用出现的次数作为权值</h4><ul><li>这里实现的思路是：将出现的字符串(C)和次数(count)保存为一个Map&lt;字符，次数&gt;对象,然后再保存为List集合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Character, Integer&gt; <span class="title">statistics</span><span class="params">(<span class="keyword">char</span>[] charArray)</span> </span>&#123;</span><br><span class="line">Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : charArray) &#123;</span><br><span class="line">Character character = <span class="keyword">new</span> Character(c);</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(character)) &#123;</span><br><span class="line">map.put(character, map.get(character) + <span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">map.put(character, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title">statisticsProbability</span><span class="params">(Map&lt;Character, Integer&gt; maps)</span> </span>&#123;</span><br><span class="line">List&lt;Node&gt; list = <span class="keyword">new</span> ArrayList&lt;TestHuffmanTree_Encode_Decode.Node&gt;();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; map : maps.entrySet()) &#123;</span><br><span class="line">Node node = <span class="keyword">new</span> Node(map.getKey().toString(), map.getValue());</span><br><span class="line">list.add(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-根据统计的List进行哈夫曼树的构造"><a href="#3-根据统计的List进行哈夫曼树的构造" class="headerlink" title="3.根据统计的List进行哈夫曼树的构造"></a>3.根据统计的List进行哈夫曼树的构造</h4><p>首先List中保存的就是Node集合，其中Node的data就是字符串，Node的weight就是出现的次数也就是权值   </p><p><b>哈夫曼树的构造:</b>   </p><ul><li>首先利用Java中的priorityQueue<e>方法进行模拟队列<br>priorityQueue<e>的用法<!-- 插入图片--> 其中主要的方法：<br>| 方法  | 作用  |<br>|—|—|<br>| add  | 将指定元素插入到次优先级队列  |<br>| poll  | 获取并且移除队列头  |<br>|  peek | 获取但是不移出队列  |</e></e></li><li>将List中的数据保存到队列里面去 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  PriorityQueue&lt;Node&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;Node&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.size(); i++) &#123;</span><br><span class="line">priorityQueue.add(nodes.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><b>然后利用poll方法获取队列头节点</b>,这里可能就由疑问了，哈夫曼树不是要求按照权值最小的两个开始组成树嘛。这里为什么随便从队列里面弄两个出来就可以。<br>其实是这样的;在Node定义的时候实现了Comparable<node>接口并且实现了compareTo（E e）方法，这里其实就已经实现了队列里面的排序<!--插入图片--></node></li><li>然后构建两个子节点的父节点，并且声明三者之间的关系(父子，左右)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">         <span class="comment">// 构建父节点</span></span><br><span class="line">Node sumNode = <span class="keyword">new</span> Node(node1.data + node2.data, node1.weight</span><br><span class="line">+ node2.weight);</span><br><span class="line"></span><br><span class="line">sumNode.leftChild = node1;</span><br><span class="line">sumNode.rightChild = node2;</span><br><span class="line"></span><br><span class="line">node1.parent = sumNode;</span><br><span class="line">node2.parent = sumNode;</span><br></pre></td></tr></table></figure><ul><li><p>然后再将父节点保存到队列中去:这样做的目的是为了得到根节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priorityQueue.add(sumNode);</span><br></pre></td></tr></table></figure></li><li><p>最后返回根节点 priorityQueue.poll();</p></li></ul><p><b>这样，到这里哈夫曼树的构建就完成了，但是既然学习了就深入一点，<br>哈夫曼树的最长用途就是用来文件压缩，因为我们知道发送一句话的时候并不是每个字母出现的频率都是一样的，有的出现的多有的出现的少，但是如果还是使用一样额编码那样会有很大的消耗，所以这里我们就用哈夫曼树实现对字符串的编码和解码</b></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;详细了解哈夫曼树和背包问题&quot;&gt;&lt;a href=&quot;#详细了解哈夫曼树和背包问题&quot; class=&quot;headerlink&quot; title=&quot;详细了解哈夫曼树和背包问题&quot;&gt;&lt;/a&gt;详细了解哈夫曼树和背包问题&lt;/h1&gt;&lt;p&gt;&lt;b&gt;写在前面&lt;/b&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最近在疯狂复习数据结构和算法，虽然看完了一部完整的视频。但是转眼看看自己手中的《剑指Offer》里面还是不是很清楚。。。而且最近也突然觉得自己知识和别人比起来就是一个渣渣。各种被人家吊打。。。&lt;/li&gt;
&lt;li&gt;&lt;b&gt;这两个算法一个（哈夫曼树）是看最近视频动手实践的，一个(背包问题)是前段时间一个面试里面的题目，当时不知道这是一个系类的问题，昨天和大神聊完天之后才明白。所以乘着短暂的热情还在就记录下来&lt;/b&gt;先从哈夫曼树开始！！
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android开源框架总结</title>
    <link href="http://simonxin.top/2017/03/14/Android%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/"/>
    <id>http://simonxin.top/2017/03/14/Android开源框架总结/</id>
    <published>2017-03-14T10:52:02.000Z</published>
    <updated>2017-05-08T11:15:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Andorid开源框架总结"><a href="#Andorid开源框架总结" class="headerlink" title="Andorid开源框架总结"></a>Andorid开源框架总结</h1><blockquote><p>本文章转载自:<a href="http://www.jianshu.com/p/e94007f59e8d" target="_blank" rel="noopener">zhuozhou810</a>，然后结合自己日常学习中用到的一些框架总结，谢谢！！！         </p></blockquote><ul><li><b>写在前面:</b><br> 最近通过Hexo+github终于弄成了一个自己像模像样的<a href="http://www.simoncode.top" target="_blank" rel="noopener">Blog</a>网站了。虽然都是跟着教程弄的，但是还是遇到了不少坑啊!四天的时间帮老师完成了一个很小的Demo，做完的时候其实内心还是很激动的。突然想到要不是写这个Demo我应该开学到现在还没有撸过代码。<br> <b>总结一下：</b>使用阿里云解析的时候记录值为:@+www，在github.io中添加CNAME指定xx域名<a id="more"></a><h2 id="图片总结"><a href="#图片总结" class="headerlink" title="图片总结"></a>图片总结</h2><img src="/images/安卓常用框架.png" alt=""></li></ul><h2 id="开源框架"><a href="#开源框架" class="headerlink" title="开源框架"></a>开源框架</h2><ul><li><a href="#网络">网络</a>  </li><li><a href="#影视频处理">影视频处理</a></li><li><a href="#View+Layout">View+Layout</a></li><li><a href="#数据库">数据库操作</a></li><li><a href="#系统层">系统层</a></li></ul><p></p><h2 id="网络">网络</h2><p></p><ul><li><b><a href="https://github.com/square/okhttp" target="_blank" rel="noopener">OkHttp</a>:比较全面的网络框架</b></li><li><b><a href="https://github.com/square/retrofit" target="_blank" rel="noopener">retrofit</a>:okhttp注解封装框架</b></li><li><b><a href="https://github.com/wyouflf/xUtils3" target="_blank" rel="noopener">xutils3</a>：我使用最多的网络请求框架</b></li><li><b><a href="https://github.com/yanzhenjie/NoHttp" target="_blank" rel="noopener">nohttp</a>:请求日志很好的开源框架</b></li></ul><p></p><h2 id="影视频处理">影视频处理</h2><p></p><ul><li><h3>视频播放</h3><ul><li><b><a href="https://github.com/lipangit/JieCaoVideoPlayer" target="_blank" rel="noopener">JieCaoVideoPlayer </a></b></li></ul></li><li><h3>图片选择</h3><ul><li><b><a href="https://github.com/pengjianbo/GalleryFinal" target="_blank" rel="noopener">GalleryFinal </a></b></li></ul></li><li><h3>图片裁剪</h3><ul><li><b><a href="https://github.com/edmodo/cropper" target="_blank" rel="noopener">cropper </a>:图片裁剪</b></li><li><b><a href="https://github.com/bm-x/PhotoView" target="_blank" rel="noopener">PhotoView</a>:图片缩放</b></li></ul></li><li><h3>图片加载</h3><ul><li><b><a href="https://github.com/square/picasso" target="_blank" rel="noopener">picasso</a></b></li><li><b><a href="https://github.com/JackCho/SmartImageView" target="_blank" rel="noopener">smartimageview</a></b></li></ul></li><li><h3>动画效果</h3><b><ul><li><a href="https://github.com/andyxialm/SmoothCheckBox" target="_blank" rel="noopener">SmoothCheckBox</a>:CheckBox</li><li><a href="https://github.com/rengwuxian/MaterialEditText" target="_blank" rel="noopener">MaterialEditText</a>:EditText</li><li><a href="https://github.com/castorflex/SmoothProgressBar" target="_blank" rel="noopener">SmoothProgressBar</a>:ProgressBar</li><li><a href="https://github.com/tyrantgit/ExplosionField" target="_blank" rel="noopener">ExplosionField</a>:视图爆炸效果</li></ul></b></li></ul><p></p><h2 id="View+Layout">View Layout</h2><p></p><ul><li><h3>屏幕适配</h3><ul><li><b><a href="https://github.com/hongyangAndroid/AndroidAutoLayout" target="_blank" rel="noopener">AndroidAutoLayout</a>:Android屏幕适配方案，直接填写设计图上的像素尺寸即可完成适配</b></li><li><b><a href="https://github.com/JulienGenoud/android-percent-support-lib-sample" target="_blank" rel="noopener">android-percent-support-lib-sample</a>:一个简单的Android适配库</b></li></ul></li><li><h3>图表控件</h3><ul><li><b><a href="https://github.com/lecho/hellocharts-android" target="_blank" rel="noopener">hellocharts-android</a>:图表支持滚动，缩放和动画</b></li><li><b><a href="https://github.com/PhilJay/MPAndroidChart" target="_blank" rel="noopener">MPAndroidChart</a>:一个流行的Android图标表</b></li></ul></li><li><h3>ViewPager相关</h3><ul><li><b><a href="https://github.com/Devlight/InfiniteCycleViewPager" target="_blank" rel="noopener">InfiniteCycleViewPager</a>:viewpage双向取向和互动效果</b></li></ul></li><li><h3>ViewPager指示器</h3> <b><ul><li><b><a href="https://github.com/hackware1993/MagicIndicator" target="_blank" rel="noopener">MagicIndicator</a>:强大，可定制，易拓展的ViewPager指示器</b></li><li><b><a href="https://github.com/Devlight/NavigationTabBar" target="_blank" rel="noopener">NavigationTabBar</a>:导航标签栏和丰富多彩的交互 </b></li></ul></b></li><li><h3>列表拖动排序、滑动删除、侧滑菜单等</h3> <ul><li><b><a href="https://github.com/yanzhenjie/SwipeRecyclerView" target="_blank" rel="noopener">SwipeRecyclerView</a>:下拉刷新框架 </b></li><li><b><a href="https://github.com/AleBarreto/DragRecyclerView" target="_blank" rel="noopener">DragRecyclerView</a>:ListView支持拖 </b></li></ul></li><li><h3>Android布局</h3> <ul><li><b><a href="https://github.com/hongyangAndroid/FlowLayout" target="_blank" rel="noopener">FlowLayout</a>:Android流式布局，支持单选、多选等，适合用于产品标签等。  </b></li></ul></li><li><h3>Fragment使用简化</h3> <ul><li><b><a href="https://github.com/YoKeyword/Fragmentation" target="_blank" rel="noopener">Fragmentation</a>:一个管理Android Fragment的框架</b></li></ul></li><li><h3>字母导航栏</h3> <ul><li><b><a href="https://github.com/zhouzhuo810/ZzLettersSideBar" target="_blank" rel="noopener">ZzLettersSideBar</a>:字母导航栏</b></li><li><b><a href="https://github.com/YoKeyword/IndexableRecyclerView" target="_blank" rel="noopener">IndexableRecyclerView</a>:提供城市选择和联系人选择等索引功能</b></li></ul></li><li><h3>角标</h3> <ul><li><b><a href="https://github.com/jgilfelt/android-viewbadger" target="_blank" rel="noopener">android-viewbadger</a>:类似QQ消息通知时候的角标</b></li></ul></li><li><h3>二维码扫描</h3> <ul><li><b><a href="https://github.com/dm77/barcodescanner" target="_blank" rel="noopener">barcodescanner</a>：二维码扫描的库</b></li></ul></li><li><h3>侧滑菜单</h3><ul><li><b><a href="https://github.com/SpecialCyCi/AndroidResideMenu" target="_blank" rel="noopener">AndroidResideMenu</a>:侧滑菜单栏</b></li></ul></li></ul><p></p><h2 id="数据库">数据库操作</h2><p></p><ul><li><b> <a href="https://github.com/wyouflf/xUtils3" target="_blank" rel="noopener">xutils3</a>:强大的Android开源框架</b></li></ul><p></p><h2 id="系统层">系统层</h2><p></p><ul><li><p></p><h3>内存管理</h3><p></p><ul><li><b><a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">leakcanary</a>:Android和Java内存管理的开源库</b></li></ul></li><li><p></p><h3>6.0权限管理</h3><p></p><ul><li><b><a href="https://github.com/yanzhenjie/AndPermission" target="_blank" rel="noopener">AndPermission</a>:Android 6.0运行时权限管理</b></li></ul></li><li><h3>线程间通信、组件间通信</h3> <ul><li><b><a href="https://github.com/greenrobot/EventBus" target="_blank" rel="noopener">EventBus</a></b></li></ul></li><li><h3>蓝牙、摄像头相关</h3><ul><li><b><a href="https://github.com/Jasonchenlijian/FastBle" target="_blank" rel="noopener">FastBle</a>:蓝牙快速开发框架</b></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Andorid开源框架总结&quot;&gt;&lt;a href=&quot;#Andorid开源框架总结&quot; class=&quot;headerlink&quot; title=&quot;Andorid开源框架总结&quot;&gt;&lt;/a&gt;Andorid开源框架总结&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文章转载自:&lt;a href=&quot;http://www.jianshu.com/p/e94007f59e8d&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;zhuozhou810&lt;/a&gt;，然后结合自己日常学习中用到的一些框架总结，谢谢！！！         &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;写在前面:&lt;/b&gt;&lt;br&gt; 最近通过Hexo+github终于弄成了一个自己像模像样的&lt;a href=&quot;http://www.simoncode.top&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Blog&lt;/a&gt;网站了。虽然都是跟着教程弄的，但是还是遇到了不少坑啊!四天的时间帮老师完成了一个很小的Demo，做完的时候其实内心还是很激动的。突然想到要不是写这个Demo我应该开学到现在还没有撸过代码。&lt;br&gt; &lt;b&gt;总结一下：&lt;/b&gt;使用阿里云解析的时候记录值为:@+www，在github.io中添加CNAME指定xx域名
    
    </summary>
    
      <category term="Android" scheme="http://simonxin.top/categories/Android/"/>
    
    
      <category term="Android" scheme="http://simonxin.top/tags/Android/"/>
    
      <category term="框架" scheme="http://simonxin.top/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="github" scheme="http://simonxin.top/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>排序算法总结(下)</title>
    <link href="http://simonxin.top/2017/03/01/%E5%8E%9F-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93-%E4%B8%8B/"/>
    <id>http://simonxin.top/2017/03/01/原-排序算法总结-下/</id>
    <published>2017-03-01T06:37:23.000Z</published>
    <updated>2017-05-08T11:15:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="4-堆排序"><a href="#4-堆排序" class="headerlink" title="4.堆排序"></a>4.堆排序</h2><ul><li><p>思路：堆就是一个完全二叉树（小顶堆），</p></li><li><p>主要解决两个问题:</p><ul><li><p>如何将n个待排序的数构建成堆</p><ul><li>输出堆顶元素之后如何调整剩下的n-1个元素，使之成为新的堆</li></ul></li></ul></li><li>时间复杂度:O(nlogn)<a id="more"></a><h3 id="图解："><a href="#图解：" class="headerlink" title="图解："></a>图解：</h3></li></ul><p><img src="http://img.blog.csdn.net/20170301143400796?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjg0NjYzNjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"> </p><p><img src="http://img.blog.csdn.net/20170301143445485?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjg0NjYzNjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现:"></a>代码实现:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">            buildMaxHeapify(a);</span><br><span class="line">            heapSort(a);</span><br><span class="line">            System.out.println(<span class="string">""</span>);</span><br><span class="line">            System.out.println(<span class="string">"****4.堆排序之后:****"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">                System.out.print(a[i] + <span class="string">","</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建初始最大堆</span></span><br><span class="line">        <span class="comment">// 假设长度为8 那么</span></span><br><span class="line">        <span class="comment">// 第一个父节点就是a[3] 左结点为:a[7]</span></span><br><span class="line">        <span class="comment">// 第二个父节点为:a[1] 左节点为:a[3] 右结点为:a[4]</span></span><br><span class="line">        <span class="comment">// 第三份父节点为:a[2] 左节点为:a[5] 右结点为:a[6]</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeapify</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"字符串的长度为:"</span> + a.length);</span><br><span class="line">            <span class="keyword">int</span> startIndex = getParentIndex(a.length - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                maxHeapify(a, a.length, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">         *            数组</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment">         *            数据长度</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">         *            当前的父节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> length, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 与当前左右结点进行比较</span></span><br><span class="line">            <span class="keyword">int</span> left = getChildLeftIndex(index);</span><br><span class="line">            <span class="keyword">int</span> right = getChildRightIndex(index);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 进行左右节点值的对比</span></span><br><span class="line">            <span class="keyword">int</span> largest = index;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; length &amp;&amp; a[left] &gt; a[index]) &#123;</span><br><span class="line">                largest = left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; length &amp;&amp; a[right] &gt; a[largest]) &#123;</span><br><span class="line">                largest = right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (largest != index) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[index];</span><br><span class="line">                a[index] = a[largest];</span><br><span class="line">                a[largest] = temp;</span><br><span class="line">                <span class="comment">// 整理节点</span></span><br><span class="line">                maxHeapify(a, length, largest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父节点的位置</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getParentIndex</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左孩子的位置</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildLeftIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右孩子的位置</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildRightIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这个函数的含义就是： 将排好的最大堆的堆顶和最后一个交换再进行最大堆排序 排序：最大值放在末尾，再次进行排序</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[<span class="number">0</span>];</span><br><span class="line">                a[<span class="number">0</span>] = a[i];</span><br><span class="line">                a[i] = temp;</span><br><span class="line">                maxHeapify(a, i, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="5-冒泡排序"><a href="#5-冒泡排序" class="headerlink" title="5.冒泡排序"></a>5.冒泡排序</h2><ul><li>思路：就是不断的两两比较</li><li><p>时间复杂度:O(n^2)</p><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><img src="http://img.blog.csdn.net/20170301143536765?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjg0NjYzNjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//简单的冒泡排序</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort_A</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length-i- <span class="number">1</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                        Swap(a, j, j + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//改进的冒泡，添加了标记</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort_B</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> n = a.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[i]&gt;a[i+<span class="number">1</span>])&#123;</span><br><span class="line">                        pos = i;</span><br><span class="line">                        Swap(a, i, i+<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                n = pos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6.快速排序"></a>6.快速排序</h2><ul><li><p>思路：</p><ul><li>选择一个基准元素</li><li>通过一次快排序将待排序数分为两个部分，一部分比基准数小，一部分比基准数大</li><li>然后接着对这两部分进行相同的操作，直到序列有序</li></ul></li><li>时间复杂度：O(nlogn)</li><li><p>空间复杂度: O(nlogn)</p><h3 id="图解：-1"><a href="#图解：-1" class="headerlink" title="图解："></a>图解：</h3><p><img src="http://img.blog.csdn.net/20170301143550828?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjg0NjYzNjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h3 id="快速排序代码"><a href="#快速排序代码" class="headerlink" title="快速排序代码"></a>快速排序代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">                <span class="keyword">int</span> privotLoc = partition(a,low,high);</span><br><span class="line">                quickSort(a, low, privotLoc-<span class="number">1</span>);</span><br><span class="line">                quickSort(a, privotLoc+<span class="number">1</span>, high);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> privotKey = a[low];</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">                <span class="keyword">while</span>(low&lt;high &amp;&amp; a[high]&gt;=privotKey)--high;<span class="comment">//从后半部分向前扫描</span></span><br><span class="line">                a[low] = a[high];</span><br><span class="line">                <span class="keyword">while</span>(low&lt;high &amp;&amp; a[low]&lt;=privotKey)++low; <span class="comment">//从前部分扫描</span></span><br><span class="line">                a[high] = a[low];</span><br><span class="line">            &#125;</span><br><span class="line">            a[high] = privotKey;</span><br><span class="line">            <span class="keyword">return</span> low;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;4-堆排序&quot;&gt;&lt;a href=&quot;#4-堆排序&quot; class=&quot;headerlink&quot; title=&quot;4.堆排序&quot;&gt;&lt;/a&gt;4.堆排序&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;思路：堆就是一个完全二叉树（小顶堆），&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;主要解决两个问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如何将n个待排序的数构建成堆&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输出堆顶元素之后如何调整剩下的n-1个元素，使之成为新的堆&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;时间复杂度:O(nlogn)
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://simonxin.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://simonxin.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://simonxin.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="排序" scheme="http://simonxin.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>排序算法总结（上）</title>
    <link href="http://simonxin.top/2017/03/01/%E5%8E%9F-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://simonxin.top/2017/03/01/原-排序算法总结（上）/</id>
    <published>2017-03-01T04:40:13.000Z</published>
    <updated>2017-05-08T11:15:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序算法总结（上）"><a href="#排序算法总结（上）" class="headerlink" title="排序算法总结（上）"></a>排序算法总结（上）</h2><blockquote><ul><li>首先先给自己大三下学期定下一个小目标:找到暑假实习公司。</li></ul></blockquote><blockquote><ul><li>因为看了很多学长学姐写的面试经验，觉得数据结构和算法是必问的内容。想想自己对这方面的脑容量为零。</li></ul></blockquote><blockquote><ul><li>所以在正式面试之前好好恶补一下！！！<a id="more"></a></li></ul></blockquote><h3 id="1-直接插入算法"><a href="#1-直接插入算法" class="headerlink" title="1.直接插入算法"></a>1.直接插入算法</h3><ul><li><p>思路： 默认前面的数据全部都是<b>已经排好</b>的，然后依次将后面的数据插入到合适的位置</p></li><li><p>时间复杂度:O(n^2)</p></li><li><p>最佳复杂度：O(n)/已经全部排好</p><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="http://img.blog.csdn.net/20170301123823950?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjg0NjYzNjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p></li></ul><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i - <span class="number">1</span>] &gt; a[i]) &#123;<span class="comment">// 注意[0,i-1]都是有序的。如果待插入元素比a[i-1]还大则无需再与[i-1]前面的元素进行比较了，反之则进入if语句</span></span><br><span class="line">                <span class="keyword">int</span> temp = a[i];</span><br><span class="line">                <span class="keyword">int</span> j;</span><br><span class="line">                <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; temp; j--) &#123;</span><br><span class="line">                    a[j + <span class="number">1</span>] = a[j];<span class="comment">// 把比temp大或相等的元素全部往后移动一个位置</span></span><br><span class="line">                &#125;</span><br><span class="line">                a[j + <span class="number">1</span>] = temp;<span class="comment">// 把待排序的元素temp插入腾出位置的(j+1)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">        System.out.println(<span class="string">"****1.直接排序之后****:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + <span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-希尔排序"><a href="#2-希尔排序" class="headerlink" title="2.希尔排序"></a>2.希尔排序</h3><ul><li><p>思路：希尔排序就是将<b>插入排序</b>基础上的将原来的间隔由1变为：(n/2),(n/4),(n/8)…直到n=1;n为数组的长度</p></li><li><p>时间复杂度:O(n^1.3)</p></li></ul><h4 id="图片解释"><a href="#图片解释" class="headerlink" title="图片解释"></a>图片解释</h4><p><img src="http://img.blog.csdn.net/20170301123849295?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjg0NjYzNjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现:"></a>代码实现:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellInsertSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> dk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = dk; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i - dk] &gt; a[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> key = a[i];</span><br><span class="line">                <span class="keyword">int</span> j;</span><br><span class="line">                <span class="keyword">for</span> (j = i - dk; j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; key; j -= dk) &#123;</span><br><span class="line">                    a[j + dk] = a[j];</span><br><span class="line">                &#125;</span><br><span class="line">                a[j + dk] = key;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.length;</span><br><span class="line">        <span class="keyword">int</span> dk = n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (dk &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            shellInsertSort(a, n, dk);</span><br><span class="line">            dk /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">        System.out.println(<span class="string">"****2.希尔排序之后****:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + <span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3.选择排序"></a>3.选择排序</h3><ul><li><p>思路：每次都选择一个最大值放在最后面，选择一个最小值放在前面,(就是将当前的数和后面所有的数比较，找到一个最小的数进行交换)</p></li><li><p>时间复杂度：O(n^2)</p></li></ul><h4 id="图片解释-1"><a href="#图片解释-1" class="headerlink" title="图片解释"></a>图片解释</h4><p><img src="http://img.blog.csdn.net/20170301123902045?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjg0NjYzNjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h4 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">                <span class="comment">// 将当前的和后面的进行对比,找出一个比当前还要小的然后和当前的进行互换位置</span></span><br><span class="line">                <span class="keyword">if</span> (a[j] &lt; a[min]) &#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">                temp = a[i];</span><br><span class="line">                a[i] = a[min];</span><br><span class="line">                a[min] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">        System.out.println(<span class="string">"****3.选择排序之后:****"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + <span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;排序算法总结（上）&quot;&gt;&lt;a href=&quot;#排序算法总结（上）&quot; class=&quot;headerlink&quot; title=&quot;排序算法总结（上）&quot;&gt;&lt;/a&gt;排序算法总结（上）&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;首先先给自己大三下学期定下一个小目标:找到暑假实习公司。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;因为看了很多学长学姐写的面试经验，觉得数据结构和算法是必问的内容。想想自己对这方面的脑容量为零。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;所以在正式面试之前好好恶补一下！！！
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://simonxin.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://simonxin.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://simonxin.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="排序" scheme="http://simonxin.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>SwipeRefreshLayout使用</title>
    <link href="http://simonxin.top/2016/12/06/%E5%8E%9F-SwipeRefreshLayout%E4%BD%BF%E7%94%A8/"/>
    <id>http://simonxin.top/2016/12/06/原-SwipeRefreshLayout使用/</id>
    <published>2016-12-06T13:21:04.000Z</published>
    <updated>2017-05-08T11:15:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SwipeRefreshLayout-使用"><a href="#SwipeRefreshLayout-使用" class="headerlink" title="SwipeRefreshLayout 使用"></a><font color="#03A9F4">SwipeRefreshLayout 使用</font></h1><blockquote><p>写在前面:最近在研究下拉刷新，虽然自己也实践写出来了一个Demo，<br>      但是还是在github上找到了一个刷新的框架<br>  框架地址:<a href="&quot;https://github.com/yanzhenjie/SwipeRecyclerView&quot;">SwipeRefreshLayout</a><br><a id="more"></a></p></blockquote><h2 id="布局文件："><a href="#布局文件：" class="headerlink" title=" 布局文件："></a><font color="#03A9F4"> 布局文件：</font></h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.v4.widget.SwipeRefreshLayout</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/id_swipe"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">ListView</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/id_listView"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"match_parent&gt;</span></span></span><br><span class="line"><span class="tag"><span class="string">       &lt;/ListView&gt;</span></span></span><br><span class="line"><span class="tag"><span class="string">&lt;/android.support.v4.widget.SwipeReuhLayot&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a><font color="#03A9F4">主要方法</font></h2><ul><li><p>setOnRefreshListener()</p><ul><li>Set the listener to be notified when a refresh is triggered via the swipe</li><li>当滑动的时候调用这个监听</li></ul></li><li><p>setColorScheme()</p><ul><li>Set the color resources used in the progress animation from color resources</li><li>设置滑动动作发生的时候的颜色源。</li></ul></li><li><p>isRefreshing()</p><ul><li>Whether the SwipeRefreshWidget is actively showing refresh  progress.</li><li>显示是否刷新进度条</li></ul></li></ul><p>##<font color="#03A9F4">实现过程</font><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Handler handler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">switch</span> (msg.what)&#123;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                   String test = (String) msg.obj;</span><br><span class="line">                   mDatas.add(test+i++);</span><br><span class="line">                   mAdapter.notifyDataSetChanged();</span><br><span class="line">                   swipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">default</span>:</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure></p><p>这里使用Handler机制是因为子线程不能刷新UI</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">OnCreate</span><span class="params">()</span></span>&#123;</span><br><span class="line">     swipeRefreshLayout =(SwipeRefreshLayout) findViewById(R.id.id_swipe);</span><br><span class="line">         listView =(ListView) findViewById(R.id.id_listView);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//刷新监听事件</span></span><br><span class="line">        swipeRefreshLayout.setOnRefreshListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        mAdapter = <span class="keyword">new</span> ArrayAdapter&lt;String&gt;(<span class="keyword">this</span>,android.R.layout.simple_list_item_1,mDatas);</span><br><span class="line">        listView.setAdapter(mAdapter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行刷新动作</span></span><br><span class="line"><span class="meta">@overrid</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRefreshListener</span><span class="params">()</span></span>&#123;</span><br><span class="line">      Message msg= <span class="keyword">new</span> Message();</span><br><span class="line">        msg.what = <span class="number">1</span>;</span><br><span class="line">        msg.obj  = <span class="string">"TEST"</span>;</span><br><span class="line">        handler.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要就是一个刷新动作的监听，然后具体实现刷新的动作</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SwipeRefreshLayout-使用&quot;&gt;&lt;a href=&quot;#SwipeRefreshLayout-使用&quot; class=&quot;headerlink&quot; title=&quot;SwipeRefreshLayout 使用&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#03A9F4&quot;&gt;SwipeRefreshLayout 使用&lt;/font&gt;&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;写在前面:最近在研究下拉刷新，虽然自己也实践写出来了一个Demo，&lt;br&gt;      但是还是在github上找到了一个刷新的框架&lt;br&gt;  框架地址:&lt;a href=&quot;&amp;quot;https://github.com/yanzhenjie/SwipeRecyclerView&amp;quot;&quot;&gt;SwipeRefreshLayout&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://simonxin.top/categories/Android/"/>
    
    
      <category term="Android" scheme="http://simonxin.top/tags/Android/"/>
    
      <category term="框架" scheme="http://simonxin.top/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Java" scheme="http://simonxin.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>短暂总结</title>
    <link href="http://simonxin.top/2016/11/30/%E5%8E%9F-%E7%9F%AD%E6%9A%82%E6%80%BB%E7%BB%93/"/>
    <id>http://simonxin.top/2016/11/30/原-短暂总结/</id>
    <published>2016-11-30T13:37:11.000Z</published>
    <updated>2017-05-08T11:15:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时间：2016年11月30日21-22-3"><a href="#时间：2016年11月30日21-22-3" class="headerlink" title="时间：2016年11月30日21:22:3"></a>时间：2016年11月30日21:22:3</h1><font size="3"></font><h2 id="开学到现在所学类容："><a href="#开学到现在所学类容：" class="headerlink" title="开学到现在所学类容："></a>开学到现在所学类容：</h2><ul><li>JavaEE三大框架</li><li>大量Android开源项目</li><li>Xutils3开源库</li><li>Nohttp开源库</li><li>&nbsp;Annotatios开源库</li><li>课本知识狗屁不通<a id="more"></a></li></ul><h2 id="近期感想"><a href="#近期感想" class="headerlink" title="近期感想"></a>近期感想</h2><p>&nbsp;&nbsp; 一进大三，就觉得就业的形式越来越严峻。虽然选择的是Android方面，但是感觉自己的基础知识非常的不好,虽然学习的是Java方面，但是感觉自己一点Java基础都没有。对一些基本的东西都不清楚，理不清，记不清楚。看到周围的人一个个都准备去考研，我一点都不为所动。因为我觉得我决定的事情一般都很难去改变。还没有进大学的时候我就决定了不去考研。感觉自己每天在教室上课都是在混吃等死。。。。。（怎么能这样评价自己呢。。。。）虽然我们这个不出名的二本院校毕业没有学校优势。但是搞技术的技术才是养活自己的本事。今天完了一款小游戏，很有意思。哇哈哈。大神的书出第二本了，等下个月又生活费了就入手一本。毕竟是大神带进门的！！！</p><h2 id="预期打算"><a href="#预期打算" class="headerlink" title="预期打算"></a>预期打算</h2><ul><li>好好学习一下C语言和C++</li><li>准备好期末复习，争取少挂科</li><li>班主任智能助手还要继续。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;时间：2016年11月30日21-22-3&quot;&gt;&lt;a href=&quot;#时间：2016年11月30日21-22-3&quot; class=&quot;headerlink&quot; title=&quot;时间：2016年11月30日21:22:3&quot;&gt;&lt;/a&gt;时间：2016年11月30日21:22:3&lt;/h1&gt;&lt;font size=&quot;3&quot;&gt;&lt;/font&gt;

&lt;h2 id=&quot;开学到现在所学类容：&quot;&gt;&lt;a href=&quot;#开学到现在所学类容：&quot; class=&quot;headerlink&quot; title=&quot;开学到现在所学类容：&quot;&gt;&lt;/a&gt;开学到现在所学类容：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;JavaEE三大框架&lt;/li&gt;
&lt;li&gt;大量Android开源项目&lt;/li&gt;
&lt;li&gt;Xutils3开源库&lt;/li&gt;
&lt;li&gt;Nohttp开源库&lt;/li&gt;
&lt;li&gt;&amp;nbsp;Annotatios开源库&lt;/li&gt;
&lt;li&gt;课本知识狗屁不通
    
    </summary>
    
      <category term="总结" scheme="http://simonxin.top/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="http://simonxin.top/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="生活" scheme="http://simonxin.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="反思" scheme="http://simonxin.top/tags/%E5%8F%8D%E6%80%9D/"/>
    
  </entry>
  
  <entry>
    <title>Ajax基本用法</title>
    <link href="http://simonxin.top/2016/11/30/%E5%8E%9F-Ajax%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <id>http://simonxin.top/2016/11/30/原-Ajax基本用法/</id>
    <published>2016-11-30T03:16:03.000Z</published>
    <updated>2017-05-08T11:15:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AJAX-异步处理"><a href="#AJAX-异步处理" class="headerlink" title="AJAX(异步处理)"></a>AJAX(异步处理)</h1><hr><h2 id="1-Ajax"><a href="#1-Ajax" class="headerlink" title="1.Ajax"></a><font color="#03a9f4">1.Ajax</font></h2><p>异步的js和xml</p><h2 id="2-同步交互和异步交互"><a href="#2-同步交互和异步交互" class="headerlink" title="2.同步交互和异步交互"></a><font color="#03a9f4">2.同步交互和异步交互</font></h2><a id="more"></a><p><strong>1.同步</strong></p><p>发送一个请求要等待服务器响应结束才可以进行下一个请求</p><p>刷新的是整个界面</p><p><strong>2.异步</strong></p><p>发送一个请求，无需等待服务器请求直接进行下一个请求</p><p>可以使用js接受服务器的响应，使用js局部刷新</p><h2 id="3-ajax请求"><a href="#3-ajax请求" class="headerlink" title="3.ajax请求"></a><font color="#03a9f4">3.ajax请求</font></h2><p><strong>第一步:(得到XMlHttpRequest）</strong></p><p>ajax只需要一个对象XMlHttpRequest，</p><p>Var xmlHtml = new XMlHttpRequest();</p><p>少数浏览器</p><p>Var xmlHtml= new ActiveXObject(“Msxml12.XMLHTTP”);</p><p>Var xmlHtml= new ActiveXObject(“Microsoft.XMLHTTP”);</p><p><strong>第二步：（得到和服务器的链接）</strong></p><p>xmlHttp.open():三个参数</p><p>—&gt;请求方式，post，get</p><p>—&gt;请求的URL，指定是想服务器的那个servlet发送请求</p><p>—&gt;请求是否为异步 true-是</p><p><strong>第三步：(发送请求)</strong></p><p>Xmlhttp.send(null):必须要给参数</p><p>参数：就是请求体类容，get的时候必须为null。</p><p><strong>第四步：(得到响应）</strong></p><p>在xmlHttp对象的上面注册监听器onreadystatechange</p><p><strong>第五步：(得到状态)</strong></p><p>状态码：</p><ul><li><p>0:刚创建，还没有调用open（）方法；</p></li><li><p>1:请求开始，调用了open（）方法,但是没有调用send（）方法；</p></li><li><p>2:调用完了send（）方法；</p></li><li><p>3:服务器开始响应，但不表示响应结束</p></li><li><p>4:服务器响应结束（通常只关心这个状态）</p></li></ul><p><strong>得到状态码：</strong></p><p>Var state = xmlHttp.readyState();可能是01234；</p><p><strong>得到服务器的响应状态码</strong></p><p>Var status =xmlHttp.status ; 可能是202 404</p><p><strong>得到服务器响应内容</strong></p><p>Var content =xmlHttp.responseText;得到的为文本可是</p><p>Var content =xmlHttp.responseXML;得到的是xml响应内容</p><p>当xmlHttp.readyState()=4 并且xmlHttp.status=200的时候证明成功，可以获得服务器响应文件</p><h2 id="4-post请求-发送请求需要带参数"><a href="#4-post请求-发送请求需要带参数" class="headerlink" title="4.post请求(发送请求需要带参数)"></a><font color="#03a9f4">4.post请求(发送请求需要带参数)</font></h2><p>xmlHttp.open(“POST”..);</p><p>需要添加一步</p><pre><code>xmlHttp.setRequestHeader(“Content-type”,”application/x-www-form-urlencoded”);xmlHttp.send(“username=”xx”,password=”x”);//发送的内容</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;AJAX-异步处理&quot;&gt;&lt;a href=&quot;#AJAX-异步处理&quot; class=&quot;headerlink&quot; title=&quot;AJAX(异步处理)&quot;&gt;&lt;/a&gt;AJAX(异步处理)&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;1-Ajax&quot;&gt;&lt;a href=&quot;#1-Ajax&quot; class=&quot;headerlink&quot; title=&quot;1.Ajax&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#03a9f4&quot;&gt;1.Ajax&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;异步的js和xml&lt;/p&gt;
&lt;h2 id=&quot;2-同步交互和异步交互&quot;&gt;&lt;a href=&quot;#2-同步交互和异步交互&quot; class=&quot;headerlink&quot; title=&quot;2.同步交互和异步交互&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#03a9f4&quot;&gt;2.同步交互和异步交互&lt;/font&gt;&lt;/h2&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="http://simonxin.top/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="http://simonxin.top/tags/JavaWeb/"/>
    
      <category term="基础" scheme="http://simonxin.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Jsp_Cookie_HttpSession_EL</title>
    <link href="http://simonxin.top/2016/11/29/%E5%8E%9F-Jsp-Cookie-HttpSession-EL/"/>
    <id>http://simonxin.top/2016/11/29/原-Jsp-Cookie-HttpSession-EL/</id>
    <published>2016-11-29T12:54:25.000Z</published>
    <updated>2017-05-08T11:15:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Jsp-amp-Cookie-amp-HttpSession-amp-EL"><a href="#Jsp-amp-Cookie-amp-HttpSession-amp-EL" class="headerlink" title="Jsp&amp;Cookie&amp;HttpSession&amp;EL"></a>Jsp&amp;Cookie&amp;HttpSession&amp;EL</h1><blockquote><p>写在前面:主要还是之前的JavaEE知识总结<br><a id="more"></a></p></blockquote><h2 id="1-Jsp基础"><a href="#1-Jsp基础" class="headerlink" title="1.Jsp基础"></a>1.Jsp基础</h2><p>1.<b> 作用：</b></p><p>在原有html基础上面添加java脚本，构成jsp页面</p><p>2.<b>Servlet:</b></p><p>虽然能够动态，但是在页面的时候需要调用函数输出在页面上面</p><p>3.<b> Html：</b></p><p>虽然能够很好的显示在网页上面，但是不能够动态的现实内容</p><p>4.<b> Jsp和servlet的分工：</b></p><ul><li><p>Jsp：请求发起页面，表单，超链接，请求结束页面，现实数据（服务员）</p></li><li><p>Servlet：请求中间处理数据（厨师）</p></li></ul><p>5.<b>Jsp组成：</b></p><ul><li><p>Jsp=html+java脚本+jsp标签</p></li><li><p>Jsp无需创建即可使用的对象（request,response）</p></li></ul><p>6.<b>三种java脚本</b></p><ul><li><p>&lt;%….%&gt;java代码片段，方法内可以放什么就可以放什么（不能放方法和成员变量）</p></li><li><p>&lt;%=…%&gt;主要用来输出，用于输出一条语句的表达式，system.out.printf（这里面的内容）</p></li><li><p>&lt;%!…%&gt;声明，变量，方法</p></li></ul><p>7.<b>Jsp原理：</b></p><p>其实就是java代码</p><p>8.<b>Jsp注释：</b></p><p>&lt;%–dasdas–%&gt;</p><h2 id="2-Cookie-域"><a href="#2-Cookie-域" class="headerlink" title="2.Cookie(域)"></a>2.Cookie(域)</h2><p><b>1.定义：</b></p><p>浏览器保存服务器的数据，第二次访问相同的页面时，浏览器将保存的数据发送到服务器</p><p><b>2.举例</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Set-Cookie aaa=AAA</span><br><span class="line"></span><br><span class="line">response.addHeader(“Set-Cookie”,”aaa=AAA”);</span><br><span class="line"></span><br><span class="line">Cookie cookie= <span class="keyword">new</span> Cookie(name,value);</span><br></pre></td></tr></table></figure><ul><li><p><b>快捷方式serponse.addCookie(cookie)</b>//向客户端发送cookie</p></li><li><p><b>request.getCookies()</b>//服务器获取从浏览器保存的cookie，返回Cookies数组</p></li><li><p><b>coookie.setMaxAge():</b>设置cookied的生命周期-1表示直接”杀死“0表示在浏览结束清楚</p></li><li><p>访问的路径要是包含了cookie的路径，那么服务器就会取得到留在浏览器的cookie值</p></li></ul><h2 id="3-HttpSession（域）-保护用户的登录信息"><a href="#3-HttpSession（域）-保护用户的登录信息" class="headerlink" title="3.HttpSession（域）**保护用户的登录信息"></a>3.HttpSession（域）<em>**</em>保护用户的登录信息</h2><blockquote><p><b>Jsp中的内置对象</b></p></blockquote><ul><li><p>服务器端对象，保存在服务器中，属于javaWab不是属于Html</p></li><li><p>调用HttpSession session = request.getSeccion();打开浏览器到关闭浏览器（一个用户）</p></li><li><p>Resquest.getSession(false):不存在session那么就会返回null</p></li></ul><blockquote><p><b>Session案例：（简单登陆页面）</b></p></blockquote><p><img src="index_files/_u7B80_u5355_u767B_u5F55_u9875_u9762_u8BBE_u8BA1_u601D_u8DEFpng.png" alt=""></p><blockquote><p><b> Session原理：</b></p></blockquote><p>和银行卡一样的，访问一次就会得到一张卡，卡里面存数据，关闭网页的时候就流失了这张卡，所以要重新分配这个卡</p><p><img src="index_files/session_u539F_u7406.png" alt=""></p><h2 id="4-Jsp三大指令"><a href="#4-Jsp三大指令" class="headerlink" title="4.Jsp三大指令"></a>4.Jsp三大指令</h2><p><b>1.Page指令：&lt;%@page %&gt; </b></p><p>pageEncoding和contentType</p><p>1. pageEncoding:指定当前的页面编码，只要是正确的，就不会乱码。服务器编译jsp成的java的时候会使用pageEncoding；</p><p>2.contentType contentType(“type/html;charset=utf-8”)都是设置jsp页面的编码。</p><p>*<b> Import :</b>导包</p><ul><li><b> ErrorPage:</b>当前页面如果抛出异常，转发到哪一个页面</li></ul><p>*<b> isErrorPage：</b>指定当前页面是否为处理错误的页面，当属性为true时，可以使用内置对象的exception</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">exception-type</span>&gt;</span><span class="tag">&lt;/<span class="name">exception-type</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">location</span>&gt;</span><span class="tag">&lt;/<span class="name">location</span>&gt;</span>将错误页面转发到新的页面</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><b> Buffer:</b>指定为缓冲区的大小，通常为8k</p></li><li><p><b> isELIgnored：</b>是否忽略el表达式（默认为false）</p></li></ul><p><b>2.Include静态包含</b></p><ul><li><p>RequesetDispatcher的include方法相似</p></li><li><p>将两个jsp页面绑在一起了，但是requestDispatcher是将两个需要的内容共享。</p></li></ul><h2 id="5-九大内置对象"><a href="#5-九大内置对象" class="headerlink" title="5.九大内置对象"></a>5.九大内置对象</h2><ul><li><p><b>Out：</b>输出</p></li><li><p><b>Config:</b>对应ServletConfig（配置）</p></li><li><p><b>Page:</b>当前jsp的this，就是当前的对象。引用为Object类型</p></li><li><p><b>pageContext：</b>最后一个域对象</p></li><li><p><b>Exception:</b>异常类的对象</p></li><li><p><b>request</b></p></li><li><p><b>Response</b></p></li><li><p><b>Application:</b>ServletContext类的对象</p></li><li><p><b>Session：</b></p></li></ul><h2 id="6-pageContext-域对象"><a href="#6-pageContext-域对象" class="headerlink" title="6.pageContext(域对象)"></a>6.pageContext(域对象)</h2><blockquote><p>四大域对象</p></blockquote><p><b>1.servletContext（域）：</b>整个应用程序</p><p><b>2.Session（域）：</b>整个会话</p><p><b>3.Request(域):</b>一个请求链</p><p><b>4.pageContext:</b>一个jsp页面，当前jsp页面和jsp标签之间共享数据。</p><ul><li><p><b> 代理其他域：</b>pageContext.setAttribute(“”,””,PageContext.Seesion_SCope)；代理session对象</p></li><li><p><b>全域查找：</b>pageContext.findAteeibute(“”):从小范围查找到大域，page的域最小</p></li></ul><p>可以通过get方法，获取其他八个内置对象</p><h2 id="7-jsp动作标签"><a href="#7-jsp动作标签" class="headerlink" title="7.jsp动作标签"></a>7.jsp动作标签</h2><p><b>动作标签是有服务器来执行，html是由浏览器执行</b></p><ul><li><p><b><a href="jsp:forward" target="_blank" rel="noopener">jsp:forward</a>:</b>转发</p></li><li><p><b><a href="jsp:include" target="_blank" rel="noopener">jsp:include</a>:</b>包含</p></li><li><p><b><a href="jsp:param" target="_blank" rel="noopener">jsp:param</a>:</b>用来作为forward和include的子标签。</p></li><li><p><code>&lt;jsp:param value=””,name=””&gt;</code></p></li></ul><p><b>被转发或者被包含的jsp的页面中就可以调用这些内容</b></p><h2 id="8-jsp在xml中的配置"><a href="#8-jsp在xml中的配置" class="headerlink" title="8.jsp在xml中的配置"></a>8.jsp在xml中的配置</h2><p>在context.xml的<code>&lt;Context reloadable=”true”&gt;</code>；自动重新加载，不用重启tomcat</p><p>在wab.xml中已经将jsp的xml文件已经写好了</p><h2 id="9-javaBean"><a href="#9-javaBean" class="headerlink" title="9.javaBean"></a>9.javaBean</h2><ul><li><p>必须为成员变量设置set，get方法（其一也是可以的）</p></li><li><p>方法名称满足一定规范，就是可以称之为属性</p></li></ul><p><br></p><ul><li>pageContext:这个是一个pageContext类型</li></ul><p><b>项目名：${pageContext.request.contextPath}</b></p><p>项目名称变为这样</p><p><img src="index_files/_u6807_u9898.png" alt="">EL自带函数库</p><p>导入自带的函数库：&lt;@taglib prefix=”fn” url=”/functions”&gt;<br><img src="index_files/1480423481684El_u81EA_u5E26_u51FD_u6570_u5E93.png" alt=""></p><p><img src="index_files/_u6807_u9898.png" alt="">EL自定义函数库：</p><p>新建一个java类，private 并且都含有返回值</p><p>要写tld文件，写在WEB-F下<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">taglib</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee</span></span></span><br><span class="line"><span class="tag"><span class="string"></span></span></span><br><span class="line"><span class="tag"><span class="string">http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">version</span>=<span class="string">"2.0"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>JSTL 1.1 functions library<span class="tag">&lt;/<span class="name">description</span>&gt;</span>//文件的名称</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">display-name</span>&gt;</span>JSTL functions<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tlib-version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">tlib-version</span>&gt;</span>//版本号码</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">short-name</span>&gt;</span>fn<span class="tag">&lt;/<span class="name">short-name</span>&gt;</span>//前缀</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">uri</span>&gt;</span>http://java.sun.com/jsp/jstl/functions<span class="tag">&lt;/<span class="name">uri</span>&gt;</span>//现在用不上</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">Tests if an input string contains the specified substring.</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>contains<span class="tag">&lt;/<span class="name">name</span>&gt;</span>/函数名称</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function-class</span>&gt;</span>org.apache.taglibs.standard.functions.Functions<span class="tag">&lt;/<span class="name">function-class</span>&gt;</span>//函数的位置，和在xml中配置servlet一样的</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function-signature</span>&gt;</span>boolean contains(java.lang.String,java.lang.String)<span class="tag">&lt;/<span class="name">function-signature</span>&gt;</span>//返回值</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">taglib</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="10-EL标签"><a href="#10-EL标签" class="headerlink" title="10.EL标签"></a>10.EL标签</h2><ul><li><p>EL是jsp内置的表达式$&lt;”name”&gt;可以全域查找也可以指定域查找</p></li><li><p>EL只能输出代替&lt;%= %&gt;标签</p></li></ul><p><br></p><blockquote><p><b>EL读取四大域</b></p></blockquote><ul><li><p>${xxx},全域查找名为xxx的属性，不存在返回空字符串</p></li><li><p>${pageScope.xxx}</p></li><li><p>${sessionScope.xxx}</p></li><li><p>${requestScope.xxx}</p></li><li><p>${applicatScope.xxx}输出指定域的属性</p></li></ul><p><br></p><ul><li>El可以直接输出内置的十一个内置对象</li></ul><p><b>其中十个是map对象</b></p><p><b>Map.key</b>可以获得键的值</p><p><b>Param:map</b>对象，键值对，键key，值是value</p><p><b>paramValues</b>：map对象，键值对，值是多个。下表</p><p><b>Header:</b>对应请求头，key头名称，value是单个值</p><p><b>headerValues:</b>请求头，对象多值</p><blockquote><p><b>Cookie:</b>Map&lt;string,cookie&gt;key是cookie的name， <b>value是cookie的对象 </b></p></blockquote><p>想要获得cookie的value必须cookie.name:只是得到cookie的对象</p><p>想要获得值还要必须cookie.name.value, cookei.getValue</p><p>Cookie.name.name cookie.getName</p><p><br></p><ul><li>pageContext:这个是一个pageContext类型</li></ul><p><b>项目名：${pageContext.request.contextPath}</b></p><p>项目名称变为这样</p><p><br></p><p><img src="index_files/1480423351511_u6807_u9898.png" alt=""><b>EL自带函数库</b></p><p>导入自带的函数库：<code>&lt;@taglib prefix=”fn” url=”/functions”&gt;</code></p><p><img src="index_files/El_u81EA_u5E26_u51FD_u6570_u5E93.png" alt=""></p><p><br></p><p><img src="index_files/1480423351511_u6807_u9898.png" alt=""><b>EL自定义函数库：</b></p><p>1.新建一个java类，private 并且都含有返回值</p><p>2.要写tld文件，写在WEB-F下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">taglib</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee</span></span></span><br><span class="line"><span class="tag"><span class="string"></span></span></span><br><span class="line"><span class="tag"><span class="string">http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">version</span>=<span class="string">"2.0"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>JSTL 1.1 functions library<span class="tag">&lt;/<span class="name">description</span>&gt;</span>//文件的名称</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">display-name</span>&gt;</span>JSTL functions<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tlib-version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">tlib-version</span>&gt;</span>//版本号码</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">short-name</span>&gt;</span>fn<span class="tag">&lt;/<span class="name">short-name</span>&gt;</span>//前缀</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">uri</span>&gt;</span>http://java.sun.com/jsp/jstl/functions<span class="tag">&lt;/<span class="name">uri</span>&gt;</span>//现在用不上</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">Tests if an input string contains the specified substring.</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>contains<span class="tag">&lt;/<span class="name">name</span>&gt;</span>/函数名称</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function-class</span>&gt;</span>org.apache.taglibs.standard.functions.Functions<span class="tag">&lt;/<span class="name">function-class</span>&gt;</span>//函数的位置，和在xml中配置servlet一样的</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function-signature</span>&gt;</span>boolean contains(java.lang.String,java.lang.String)<span class="tag">&lt;/<span class="name">function-signature</span>&gt;</span>//返回值</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">taglib</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="11-Jspl"><a href="#11-Jspl" class="headerlink" title="11.Jspl"></a>11.Jspl</h2><h3 id="Jspl包含四大标签库："><a href="#Jspl包含四大标签库：" class="headerlink" title="Jspl包含四大标签库："></a>Jspl包含四大标签库：</h3><p><img src="index_files/1480423331474_u6807_u9898.png" alt="">导入jspl标签库（动态标签是在服务器中执行）</p><p><code>&lt;%@taglib prefix=”前缀” url=””%&gt;</code></p><p><b>1. 核心标签库：Core</b></p><p><b>Out</b></p><p><code>&lt;c:out value=”” escapeXml=”true”/转移”&lt;&gt;“&gt;</code>可以输出${}中的内容</p><p><b>Set</b></p><p>创建域的属性</p><p><code>&lt;c:set var=””,value=”” scope=”设置在指定域”&gt;</code>默认设置的是在page中</p><p>Var：变量名 value:变量值,scope=”设置在指定域”</p><p><b>Remove</b></p><p><code>&lt;remove&gt;</code>:删除域变量</p><p>Var:变量名 scope：删除指定域的内容，否咋就删除了所有域中的内容</p><p><b>Url</b></p><p>Value:指定一个路径，会直接在给定的值前面加上项目名</p><p>&lt;c:url value=”/a.jsp”&gt;</p><p><code>&lt;c:param name=””,value=””&gt;</code>输出为项目名/a.jsp?名称的URL编码，子标签</p><p>&lt;/c:url&gt;</p><p><b>If</b></p><p><code>&lt;c:if text=””&gt;&lt;/c:if&gt;</code>必须要有一个bool类型的值，当text为真得时候执行标签体类容</p><p><b>Choose</b></p><p>对应java中的if else</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">c:choose</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">c:when</span> <span class="attr">text</span>=<span class="string">””</span>&gt;</span><span class="tag">&lt;/<span class="name">c:when</span>&gt;</span> if</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">c:whentext=””</span>&gt;</span><span class="tag">&lt;/<span class="name">c:when</span>&gt;</span>只有当第一个为假的之后才会执行这个</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">c:otherwise</span>&gt;</span><span class="tag">&lt;/<span class="name">c:otherwise</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">c:choose</span>&gt;</span></span><br></pre></td></tr></table></figure><p><b>forEach</b></p><p>循环遍历数组集合，技术方式来循环</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">c:forEach</span> <span class="attr">var</span>=<span class="string">”i”</span> <span class="attr">begin</span>=<span class="string">”1”</span> <span class="attr">end</span>=<span class="string">”10”</span> <span class="attr">step</span>=<span class="string">””</span>&gt;</span>从一到十 包含十</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">c:forEach</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">c:forEach</span> <span class="attr">items</span>=<span class="string">””</span> <span class="attr">var</span>=<span class="string">””</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">c:forEach</span>&gt;</span></span><br></pre></td></tr></table></figure><p>循环变量<br><img src="index_files/19566bd5-3bb0-4e67-bd65-611373f3970c.jpg" alt=""></p><p><b>Fmt</b></p><p>格式化输出库</p><p>&lt;fmt:frmatDate value=”” pattern=””&gt;</p><h3 id="自定义标签"><a href="#自定义标签" class="headerlink" title="自定义标签"></a>自定义标签</h3><p>1. 自定义一个类</p><p>2. 写一个tld文件，相当于xml文件</p><p>3. 在jsp中调用tld文件</p><hr><p><b>标签处理类：</b></p><p><b>SimpleTag</b>接口</p><p><b>Void doTag():</b>每次执行都会调用这个方法</p><p><b>Void setParent(JspTag):</b>设置父标签（不是生命周期方法）</p><p><b>JspTag getParent():</b>返回父标签</p><p><b>**Void setJspBody(JspFragment):</b>设置标签体</p><p><b>**Void setJspContext(JspContext):</b>设置jsp上下文对象</p><p><b>doTag()</b>这个方法最后使用</p><hr><p><b>创建tld文件</b></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tag</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span><span class="tag">&lt;/<span class="name">name</span>&gt;</span><span class="comment">&lt;!-- 标签名称 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tag-class</span>&gt;</span><span class="tag">&lt;/<span class="name">tag-class</span>&gt;</span><span class="comment">&lt;!--标签处理类，加包名称 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body-content</span>&gt;</span>empty<span class="tag">&lt;/<span class="name">body-content</span>&gt;</span><span class="comment">&lt;!--标签内容 empty空标签 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br></pre></td></tr></table></figure><p><b>标签内容：</b></p><p><b>scriptless:</b>只能是el表达式，也可以是其他的标签</p><p><b>this.getJspContext().getOut()</b>获得输出流</p><p><b>this.getJspBody().invoke(‘输出流’)</b>//执行标签体</p><p><b>this.getJspBody.invoke(null)</b>//执行标签体</p><hr><p><b>在页面中调用这个tld文件</b></p><p>&lt;@%taglib prefix=”短名称” url=”标签所在的位置路径”%&gt;</p><p>&lt;”短名称”,在tld定义的名称&gt;</p><p>Throw new SkippageException抛出这个异常之后，本jsp页面下面的内容不再显示</p><p><b>标签属性：</b></p><p>在标签处理类里面添加属性</p><p>设置boolean text的属性，设置get，set方法，也是在doTag之前，值是有tomcat传入</p><p>If(text){this.getJspBody.invoke(null)}执行标签体</p><p><b>在tld中添加属性</b></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body-content</span>&gt;</span>scriptless<span class="tag">&lt;/<span class="name">body-content</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">attribute</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>:属性名称<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">required</span>&gt;</span>true<span class="tag">&lt;/<span class="name">requirde</span>&gt;</span>//指定属性是否为必须的</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rtexprvalue</span>&gt;</span>true<span class="tag">&lt;/<span class="name">rtexprvalue</span>&gt;</span>//能否使用EL语句</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">attribute</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="12-Mvc"><a href="#12-Mvc" class="headerlink" title="12.Mvc"></a>12.Mvc</h2><ul><li><p>M–model 模型(自己写的代码) 统一调度</p></li><li><p>V-view 视图(jsp) 显示</p></li><li><p>C-Controller 控制器（servlet） 处理</p></li></ul><p>javaWab三层框架</p><ul><li><p>Wab层 与wab相关的内容</p></li><li><p>业务层 业务对象</p></li><li><p>数据层 操作数据库</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Jsp-amp-Cookie-amp-HttpSession-amp-EL&quot;&gt;&lt;a href=&quot;#Jsp-amp-Cookie-amp-HttpSession-amp-EL&quot; class=&quot;headerlink&quot; title=&quot;Jsp&amp;amp;Cookie&amp;amp;HttpSession&amp;amp;EL&quot;&gt;&lt;/a&gt;Jsp&amp;amp;Cookie&amp;amp;HttpSession&amp;amp;EL&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;写在前面:主要还是之前的JavaEE知识总结&lt;br&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="http://simonxin.top/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="http://simonxin.top/tags/JavaWeb/"/>
    
      <category term="基础" scheme="http://simonxin.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Java" scheme="http://simonxin.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript基础知识总结</title>
    <link href="http://simonxin.top/2016/11/24/%E5%8E%9F-JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://simonxin.top/2016/11/24/原-JavaScript基础知识总结/</id>
    <published>2016-11-24T14:10:14.000Z</published>
    <updated>2017-05-08T11:15:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JavaScript基础知识"><a href="#JavaScript基础知识" class="headerlink" title="JavaScript基础知识"></a><font color="#9AD6E6">JavaScript基础知识</font></h3><ul><li><p>alert()：弹出窗口</p></li><li><p>document.write(“”):将值直接显示在页面上面（包括heml代码）</p></li></ul><h4 id="1-Js-类型"><a href="#1-Js-类型" class="headerlink" title="1.Js 类型"></a>1.Js 类型</h4><p>var string</p><h4 id="2-数组定义"><a href="#2-数组定义" class="headerlink" title="2.数组定义"></a>2.数组定义</h4><p>一：var arr=[1,2,3];</p><p>二：var arr = new Array(3):代表数组的长度 arr[0]=””;arr[1]=””;arr[2]=””;</p><p>三：var arr = new array[1,2,3]代表数组中的值</p><p>length:数组长度<br><a id="more"></a></p><h4 id="3-javascript中关于string的方法"><a href="#3-javascript中关于string的方法" class="headerlink" title="3.javascript中关于string的方法"></a>3.javascript中关于string的方法</h4><ul><li><p><font color="#3CA9EE" size="5">bold</font>:将字体加黑</p></li><li><p><font color="#3CA9EE" size="5">fontcolor</font>:字体颜色</p></li><li><p><font color="#3CA9EE" size="5">fontsize</font>:字体的大小数值只能是1-7</p></li></ul><p><code>document.write(string.fontsize());</code></p><ul><li><font color="#3CA9EE" size="5">link</font>:将字体变为超链接</li></ul><p><code>&lt;font color=#3CA9EE size=&quot;5&quot;&gt;document.write(string.link(&quot;地址&quot;));</code></p><ul><li><p><font color="#3CA9EE" size="5">sub</font>:下标 <font color="red" size="5">sut</font>:上标</p></li><li><p><font color="#3CA9EE" size="5">concat</font>:字符串的连接</p></li></ul><p><code>document.write(str1.concat(str2));</code></p><ul><li><font color="#3CA9EE" size="5">charAt</font>：返回指定位置的字符串</li></ul><p><code>document.write(string.charAt(0)); 返回字符串中第一个的位置</code></p><ul><li><font color="#3CA9EE" size="5">indexOf</font>：返回传入字符串的位置</li></ul><p><code>document.write(string.indexOf(&quot;字符&quot;));不存在时候返回-1</code></p><ul><li><font color="#3CA9EE" size="5">split</font>:将字符串切分</li></ul><p><code>document.write(string.split(&quot;-&quot;));按照-来切分一个字符串，切分成数组</code></p><ul><li><font color="#3CA9EE" size="5">replace</font>:替换字符串</li></ul><p><code>document.write（string.replace(&quot;要替换的值&quot;,&quot;替换成的值&quot;)）</code></p><p><code>substr:substr(5,5) 从第五位开始截取，截取五位字符</code></p><p><code>substring:substring（3,5） 从第三位截取到第五位，但是不包含第五位</code></p><h4 id="4-javascript中关于array的方法"><a href="#4-javascript中关于array的方法" class="headerlink" title="4.javascript中关于array的方法"></a>4.javascript中关于array的方法</h4><ul><li><p><font color="#3CA9EE" size="5"> length</font>:长度的函数</p></li><li><p><font color="#3CA9EE" size="5">join</font>:按照指定的字符将数组分割arr（1,2,3） arr.join（“-”） 显示的是arr（1-2-3）</p></li><li><p><font color="#3CA9EE" size="5">push </font>: arr.push(“你想加的数据”) 返回值为数组串的长度</p></li><li><p><font color="#3CA9EE" size="5"> pop</font> : 删除最后一个字符串并将之返回</p></li><li><p><font color="#3CA9EE" size="5">reverse</font>： 颠倒数组中的顺序 arr.reverse();</p></li></ul><h4 id="5-javascript中Date的方法"><a href="#5-javascript中Date的方法" class="headerlink" title="5.javascript中Date的方法"></a>5.javascript中Date的方法</h4><h5 id="var-date-new-Date"><a href="#var-date-new-Date" class="headerlink" title="var date = new Date();"></a>var date = new Date();</h5><p>1.<font color="#3CA9EE" size="4">得到本地的时间是</font>: date.toLocaleString</p><p>2.<font color="#3CA9EE" size="4"> 得到当前的年</font> ：date.getFullYear</p><p>3.<font color="#3CA9EE" size="4"> 得到当前的月 </font> ：date.getMonth 返回的值为0-11 得到当前的值必须要加1</p><p>4.<font color="#3CA9EE" size="4"> 得到当前的星期 </font>：date.getDay 返回值也为0-6 星期日返回值为0</p><p>5.<font color="#3CA9EE" size="4"> 得到当前的天 </font> ：date.getDate</p><p>6.<font color="#3CA9EE" size="4"> 得到当前的小时</font> ：date.hetHours</p><p>7.<font color="#3CA9EE" size="4">得到当前的分钟</font> ：date.getMinutes</p><p>8.<font color="#3CA9EE" size="4"> 得到当前的分钟</font> ：date.getSeconds</p><p>9.<font color="#3CA9EE" size="4">获取毫秒数 </font> ：date.getTimes 返回1970年0月0日到现在的毫秒数 //应用场景：不有缓存，解决缓存</p><h4 id="6-javascript中math的方法"><a href="#6-javascript中math的方法" class="headerlink" title="6.javascript中math的方法"></a>6.javascript中math的方法</h4><blockquote><p>都是静态方法 都是通过<b>Math.</b>来使用</p></blockquote><p>1.<font color="#3CA9EE" size="4">ceil</font> : document.write(Math.ceil(m)); 向上舍入（10.4—&gt;11）</p><p>2.<font color="#3CA9EE" size="4">floor</font> : document.write(Math.floor(m));向下舍入（10.4—&gt;10）</p><p>3.<font color="#3CA9EE" size="4">round</font> : document.write(Math.round(m));四舍五入（10.4—&gt;10）</p><p>4.<font color="#3CA9EE" size="4">random</font> ： 产生0-1之间的随机数</p><blockquote><font size="4">javascript中不存在函数的重载，通过其他方式模拟重载（arugument数组来重载）</font></blockquote><h4 id="7-javascript的Bom对象"><a href="#7-javascript的Bom对象" class="headerlink" title="7.javascript的Bom对象"></a>7.javascript的Bom对象</h4><p>1.<font color="#3CA9EE" size="4">navigator</font> ：获取浏览器的信息</p><p>2.<font color="#3CA9EE" size="4">navigator.appname</font> :获取浏览器名称</p><p>3.<font color="#3CA9EE" size="4">screen </font> ：浏览器屏幕信息</p><p>4.<font color="#3CA9EE" size="4">location </font></p><p>5.<font color="#3CA9EE" size="4">href</font> :获取请求的地址，设置url地址</p><p>6.<font color="#3CA9EE" size="4">history</font></p><p>7.<font color="#3CA9EE" size="4">back </font> :上一个页面</p><p>8.<font color="#3CA9EE" size="4">forward</font> ：下一个页面</p><h5 id="9-windows"><a href="#9-windows" class="headerlink" title="9. windows"></a>9. windows</h5><ul><li><p><font color="#3CA9EE" size="4">window.alert</font> :输出弹框</p></li><li><p><font color="#3CA9EE" size="4">window.confirm (“显示内容”）</font> :确认提示框（点击确定返回true，取消返回false）</p></li><li><p><font color="#3CA9EE" size="4">window.prompt（“显示的内容”，“默认内容”） </font> :文字提示框</p></li><li><p><font color="#3CA9EE" size="4">window.open（链接，名字，格式）</font> ：打开一个新的窗口</p></li><li><p><font color="#3CA9EE" size="4">window.clouse() </font> : 关闭窗口</p></li><li><p><font color="#3CA9EE" size="4">window.setInterval(‘js代码’，毫秒数)</font> ：多长时间执行一次“js代码事件”(模拟定时器的效果)</p></li><li><p><font color="#3CA9EE" size="4">window.setT imeout(“js代码”，毫秒数)</font> : 在毫秒数之后去执行“js代码事件”（只会执行一次）</p></li><li><p><font color="#3CA9EE" size="4">clearInterval(传入的为Interval事件的ID)</font> : 清除setInterval的事件</p></li><li><p><font color="#3CA9EE" size="4">clearInterval() </font> ：清除setTimeout事件</p></li></ul><h4 id="8-javascript的dom对象"><a href="#8-javascript的dom对象" class="headerlink" title="8.javascript的dom对象"></a>8.javascript的dom对象</h4><blockquote></blockquote><ul><li><p>文档： 超文本标记文档</p></li><li><p>对象：提供属性和方法</p></li><li><p>模型：使用属性和方法操作的文档</p></li></ul><h4 id="9-javascript的document方法"><a href="#9-javascript的document方法" class="headerlink" title="9.javascript的document方法"></a>9.javascript的document方法</h4><p>1. <font color="#3CA9EE" size="4">write</font> :向页面输出变量的值或者HTML代码</p><p>2. <font color="#3CA9EE" size="4">getElementById</font> :通过Id来得到对象</p><p>3. <font color="#3CA9EE" size="4">getElementsByName(“name的值为一样的组”)</font> :通过标签的name值得到对象，返回的是一个数组</p><p>4. <font color="#3CA9EE" size="4">getElementsTagName(“标签名称”)</font> ：通过标签名称得到对象，返回也是一个数组</p><p>5. 只有一个标签时，只能用ByName来获取，不能使用ByTagName获取</p><p>6. <font color="#3CA9EE" size="4">opener</font>:创建窗口的窗口 var p=window.opener p得到了创建这个字窗口的窗口 在末尾添加节点：</p><blockquote><p>1.获取母标签getById<br><br></p></blockquote><blockquote><p>2.创建子标签</p></blockquote><p>document.createElement(‘输入标签’); :创建标签<br><br></p><blockquote><p>3.创建所要输入的文本<br></p></blockquote><p>document.createTextNode(“输入文本”) :创建文本<br><br></p><blockquote><p>4.将文本放入标签中<br></p></blockquote><p>子标签.appendChild（”文本”） :将文本让入子标签中<br><br></p><blockquote><p>5.将子标签放入母标签中<br></p></blockquote><p>母标签.oppendChild(); :将子标签插入到母标签中（类似于剪切粘贴的效果）</p><h4 id="10-javascript的Element对象"><a href="#10-javascript的Element对象" class="headerlink" title="10.javascript的Element对象"></a>10.javascript的Element对象</h4><p>1.<font color="#3CA9EE" size="4">input.value</font>;</p><p>2.<font color="#3CA9EE" size="4">input.getAttribute(“value”)</font>; :两个效果是一样的，但是使用后者是区别关键字</p><p>3.<font color="#3CA9EE" size="4">inout.setAttribute(“属性”,”属性值”)</font>; :设置属性名称和值，传入两个参数</p><p>4.<font color="#3CA9EE" size="4">inout.removeAttribute(“属性”)</font> ：删除属性，但是不能删除value属性</p><p>5.<font color="#3CA9EE" size="4">node:标签节点</font></p><blockquote><p><b>nodeType nodeName nodeValue</b></p></blockquote><blockquote><p><font color="#3CA9EE" size="4">fistChild </font> :获得第一个节点</p></blockquote><blockquote><p><font color="#3CA9EE" size="4">lastChild</font> :获得最后一个节点</p></blockquote><blockquote><p><font color="#3CA9EE" size="4">nextSibling</font> :子节点中的下一个同辈节点</p></blockquote><blockquote><p><font color="#3CA9EE" size="4">previousSibling</font> :子节点中的上一个同辈节点</p></blockquote><h4 id="11-javascript的Dom操作"><a href="#11-javascript的Dom操作" class="headerlink" title="11.javascript的Dom操作"></a>11.javascript的Dom操作</h4><p><font color="#3CA9EE" size="4">oppendChild();</font> :将子标签插入到母标签中（类似于剪切粘贴的效果）</p><p><font color="#3CA9EE" size="4">insertBefore(新节点，旧节点)</font> :将新节点插入到旧节点之前（是在母节点的基础上插入）</p><p><font color="#3CA9EE" size="4">replace(新节点，旧节点)</font> :将新节点代替旧节点（是在母节点的基础上替换）</p><p><font color="#3CA9EE" size="4">cloneNode(bool类型)</font> :复制子节点子 节点.cloneNode(true);</p><p><font color="#3CA9EE" size="4">removeNode(子节点)</font> :通过父节点删除子节点</p><h4 id="12-javascript的innerHTML属性"><a href="#12-javascript的innerHTML属性" class="headerlink" title="12.javascript的innerHTML属性"></a>12.javascript的innerHTML属性</h4><blockquote><p>1.获取文本内容<br></p></blockquote><p>就是直接获得标签的文本内容</p><p>2.向标签中设置内容，包括html代码</p><blockquote><p>母节点,innerHTNL=”htnl代码”;</p></blockquote><blockquote><p><font color="#3CA9EE" size="4">form.submit();</font> :提交内容到服务器</p></blockquote><blockquote><p><font color="#3CA9EE" size="4">form.action=””;</font> :将内容提交到那个地址</p></blockquote><blockquote><p>&lt;a href=”地址”?”内容”&gt; :使用超链接提交内容</p></blockquote><blockquote><p><font color="#3CA9EE" size="4">onclick</font> :鼠标点击事件</p></blockquote><blockquote><p><font color="#3CA9EE" size="4">onchange</font> :改变内容（select一起使用）</p></blockquote><blockquote><p><font color="#3CA9EE" size="4">onfocus</font> :得到焦点事件</p></blockquote><blockquote><p><font color="#3CA9EE" size="4">onblur</font> :失去焦点事件</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JavaScript基础知识&quot;&gt;&lt;a href=&quot;#JavaScript基础知识&quot; class=&quot;headerlink&quot; title=&quot;JavaScript基础知识&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#9AD6E6&quot;&gt;JavaScript基础知识&lt;/font&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;alert()：弹出窗口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;document.write(“”):将值直接显示在页面上面（包括heml代码）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;1-Js-类型&quot;&gt;&lt;a href=&quot;#1-Js-类型&quot; class=&quot;headerlink&quot; title=&quot;1.Js 类型&quot;&gt;&lt;/a&gt;1.Js 类型&lt;/h4&gt;&lt;p&gt;var string&lt;/p&gt;
&lt;h4 id=&quot;2-数组定义&quot;&gt;&lt;a href=&quot;#2-数组定义&quot; class=&quot;headerlink&quot; title=&quot;2.数组定义&quot;&gt;&lt;/a&gt;2.数组定义&lt;/h4&gt;&lt;p&gt;一：var arr=[1,2,3];&lt;/p&gt;
&lt;p&gt;二：var arr = new Array(3):代表数组的长度 arr[0]=””;arr[1]=””;arr[2]=””;&lt;/p&gt;
&lt;p&gt;三：var arr = new array[1,2,3]代表数组中的值&lt;/p&gt;
&lt;p&gt;length:数组长度&lt;br&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="http://simonxin.top/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="http://simonxin.top/tags/JavaWeb/"/>
    
      <category term="基础" scheme="http://simonxin.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Java" scheme="http://simonxin.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>XML基础知识总结</title>
    <link href="http://simonxin.top/2016/11/24/%E5%8E%9F-XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://simonxin.top/2016/11/24/原-XML基础知识总结/</id>
    <published>2016-11-24T14:09:30.000Z</published>
    <updated>2017-05-08T11:15:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Xml基础知识"><a href="#Xml基础知识" class="headerlink" title="Xml基础知识"></a>Xml基础知识</h1><blockquote><p>写在前面:今天有时间就把以前学习JavaEE的时候记录的笔记总结了一下。<br>  主要包含XMl的基础和解析技术。<br><a id="more"></a></p></blockquote><p><br></p><p><br></p><h2 id="1-XML属性"><a href="#1-XML属性" class="headerlink" title="1.XML属性"></a>1.XML属性</h2><p><b>&lt;?xml version=”1.0” encoding=”gbk”?&gt;</b></p><blockquote><ul><li>xml的声明文件（必须写在第一行第一列）</li></ul></blockquote><ul><li><p>vareion:版本 encoding:编码gbk utf-8</p></li><li><p>乱码是因为属性的编码情况和系统的不一样</p></li></ul><p><br></p><p><br></p><p><br></p><p><br></p><h2 id="2-XML得约束：排除一些不需要的条件"><a href="#2-XML得约束：排除一些不需要的条件" class="headerlink" title="2.XML得约束：排除一些不需要的条件"></a>2.XML得约束：排除一些不需要的条件</h2><p><br></p><h3 id="dtd约束"><a href="#dtd约束" class="headerlink" title="dtd约束:"></a><b>dtd约束:</b></h3><p><b> 1.创建后缀名为.dtd文件 </b></p><blockquote><p>1.看xml中有多少个元素，有多少个就在dtd中写几个&lt;!ELEMENT&gt;</p></blockquote><blockquote><p>2.看元素什么为<b>简单元素（没有字元素）</b>和<b>复杂元素（含有子元素）</b></p></blockquote><blockquote><blockquote><p>复杂元素：元素名称 （子元素名称）&lt;!ELEMENT 元素名称“这个之间必须有空格”(子元素名称）&gt;</p></blockquote></blockquote><blockquote><blockquote><p>简单元素：元素名称 （#PCDATA）</p></blockquote></blockquote><blockquote><p>3.dtd文件的导入：</p></blockquote><p>&lt;!DOCTYPE 根元素名称 SYSTEM “文件的路径”&gt;</p><p><b>2.在xml中直接使用dtd约束</b></p><p>&lt;!DOCTYPE 根元素名称 [“定义的&lt;!ELEMENT&gt;”]&gt; 使用这种方法直接将dtd放在xml中</p><p><b>3.元素的约束：</b></p><p><img src="7ca0c1e9-077e-4005-a0b5-d166266627e0_files/DTD_u5C5E_u6027_u7684_u5B9A_u4E49.png" alt="DTD属性的定义.png"></p><p><em><b>1.简单元素的约束（没有子元素的约束）</b></em></p><blockquote><p>(#PCDATA):元素为字符串类型</p></blockquote><blockquote><p>EMPTY:元素的值为空</p></blockquote><blockquote><p>ANY：随便什么都可以</p></blockquote><p><em><b>2.复杂元素的约束（有子元素的约束）</b></em></p><blockquote><p>&lt;!DOCTYPE 复杂元素 （子元素）[]&gt;</p></blockquote><blockquote><p>都是放在样约束的后面</p></blockquote><blockquote><p><b>+:</b>表示子元素出现一次或者多次</p></blockquote><blockquote><p><b>?:</b>表示子元素出现零次或者一次</p></blockquote><blockquote><p><b>*:</b>表示子元素随便都可以</p></blockquote><blockquote><p>子元素之间用逗号<b>“,”</b>隔开： 表示子元素出现的顺序</p></blockquote><blockquote><p>子元素之间用竖线<b>“|”</b>隔开： 表示子元素只能出现其中的任意一个</p></blockquote><p><b>4.元素属性的定义：</b></p><p><b>&lt;!ATTLIST 元素名称 属性名 属性类型 属性约束&gt;</b></p><p><em><b>属性类型：</b></em></p><p><b>CDATA：</b>字符串类型的值</p><p><b>枚举类型：</b>值必须为定义中的一个 定义（aaa|bbb|ccc）</p><p><b>ID:</b>属性的值不能重复，且只能由字母下划线开头</p><p><em><b>属性约束：</b></em></p><p><b>#REQUIRED:</b>表示该属性必须出现</p><p><b>#IMPLIED:</b>表示该属性出现可有可无</p><p><b>#FIXED:</b>该属性的值为固定值 语法：#FIXED “值”</p><p><b>直接为值：</b>该值为属性的默认值</p><p><b>5.实体的定义</b></p><p><entity 实体名="" "实体值"=""> 使用&amp;实体名; 记得分号 一般都是写在内部定义的</entity></p><p><br></p><p><br></p><h3 id="Schema约束："><a href="#Schema约束：" class="headerlink" title="Schema约束："></a>Schema约束：</h3><p><b>1.定义</b></p><p>Schema符合xml语法，xml语句。xml中可以包含多个Schema，通过名称空间来区分（类似于java的包），</p><p>可以直接用Int string 类型来定义，但是Schema更复杂。</p><p><b>2.创建一个Schema文件：</b></p><p><b>复杂元素：</b></p><p><b><code>&lt;complexType&gt;</code></b></p><p><b><code>&lt;sequence&gt;</code></b></p><p><b>简单元素:</b></p><p><b><code>&lt;/sequence&gt;</code></b></p><p><b><code>&lt;/complexType&gt;</code></b></p><hr><p><b><code>&lt;sequence&gt;</code></b> :出现的元素是按照顺序的</p><p><b><code>&lt;all&gt;</code></b> :单个标签只能出现一个</p><p><b><code>&lt;choice&gt;</code></b> :子标签只能出现一个</p><p><b><code>&lt;any&gt;</code></b> ：随便出现一个标签</p><p><b>maxOccurs=”unbounded” </b> :在子标签中，表示标签可以出现无数次</p><p><b><code>&lt;attribute&gt;</code></b> :定义属性，只有在复杂元素中才可以定义属性，在<b><code>&lt;/complexType&gt;</code></b>前面写</p><hr><p><b>两个Schema应用的时候，用引入Schema别名:标签名称</b></p><ul><li>比如<b><code>&lt;check:name&gt;&lt;/check:name&gt;</code></b>这种方法调用</li></ul><p><br></p><h3 id="在xml中引入约束xsd"><a href="#在xml中引入约束xsd" class="headerlink" title="在xml中引入约束xsd"></a>在xml中引入约束xsd</h3><ul><li><p>xmlns:check=”<a href="http://www.w3.org/2001/XMLSchema-instance&quot;" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema-instance&quot;</a> “-instance”表示被约束的意思</p></li><li><p>xmlns=”<a href="http://www.example.org/jaxpText_02&quot;" target="_blank" rel="noopener">http://www.example.org/jaxpText_02&quot;</a></p></li><li><p>check:schemaLocation=”<a href="http://www.example.org/jaxpText_02" target="_blank" rel="noopener">http://www.example.org/jaxpText_02</a> jaxpText_02.xsd”</p></li><li><p>check是用户自定义的名称，xmlns：的值为xsd中targetNamespace的值</p></li><li><p>checj:schemaLocation=“targetNamespace的值 xsd的文件名称”</p></li></ul><p><br></p><p><br></p><p><br></p><h2 id="3-XML和java的结合"><a href="#3-XML和java的结合" class="headerlink" title="3.XML和java的结合"></a>3.XML和java的结合</h2><p>1.使用dom解析xml（内存中分配树装结构）</p><p>2.使用sax解析：采用事件驱动，边读变解析（从上到下，一行一行的解析，解析到一个对象，返回对象名）</p><p><br></p><p><br></p><p><br></p><h2 id="4-XML的解析"><a href="#4-XML的解析" class="headerlink" title="4.XML的解析"></a>4.XML的解析</h2><h3 id="1-dom解析"><a href="#1-dom解析" class="headerlink" title="1.dom解析"></a>1.dom解析</h3><p><b>documentBuilder:解析器类</b></p><p><em><b>抽象类 不能直接new 要使用documentBuilderFactory.newdocumentBuilder调用</b></em></p><p><b> 1.直接解析xml方法:parse(“xml路径”),返回整个Document文档</b></p><p><b><code>Document document = bulider.parse(&quot;XML路径&quot;);</code></b></p><p><b>2.document的父节点是Node</b></p><h5 id="document的方法："><a href="#document的方法：" class="headerlink" title="document的方法："></a>document的方法：</h5><blockquote><p><b>getElementsByTagName ：</b>返回得到的标签，集合</p></blockquote><blockquote><p><b>createElement :</b>创建标签</p></blockquote><blockquote><p><b>createTextNode :</b>创建文本内容</p></blockquote><blockquote><p><b>appendChild :</b>将内容插到末尾（粘贴）</p></blockquote><h5 id="NodeLise（数组）："><a href="#NodeLise（数组）：" class="headerlink" title="NodeLise（数组）："></a>NodeLise（数组）：</h5><blockquote><p><b>getlength() :</b>获得数组的长度</p></blockquote><blockquote><p><b>item(数组) :</b>获得当前位置的值</p></blockquote><blockquote><p><b>getTextContent() :</b>得到标签中的内容</p></blockquote><p><b>3.将在dom解析器中写的内容回写到xml中，利用这个方法回写</b></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">TransformerFactory factory = TransformerFactory.newInstance();</span><br><span class="line"></span><br><span class="line">Transformer transformer = factory.newTransformer();</span><br><span class="line"></span><br><span class="line">transformer.transform(new DOMSource(document), new StreamResult("src/jaxpText_01.xml""xml路径"));</span><br></pre></td></tr></table></figure><p><b>documentBuilderFactory ：</b>解析器工厂</p><p>_<b>也是抽象类，使用newInstance()调用</b></p><p>DocumentBuilderFactory builderfactory = DocumentBuilderFactory.newInstance();创建实例builderfactory _</p><p><br></p><h3 id="2-sax解析"><a href="#2-sax解析" class="headerlink" title="2.sax解析"></a>2.sax解析</h3><p><b>SAXParser:解析类</b></p><p><em><b>通过SAXParserFactory .newSAXParser来得到；</b></em></p><p>parise(“xml路径”,”执行的事件”);</p><p>{</p><p>startElement():解析开始标签，返回qName:标签名称</p><p>characters() :解析文本内容，通过string构造方法返回</p><p>endElement() :解析结束标签，也是通过qName返回标签名称</p><p>} 都是自动完成的。</p><p><em><b>SAXParserFactory :解析器工厂通过newInstance()来得到。</b></em></p><p><br></p><h3 id="3-dom4j解析（重点）"><a href="#3-dom4j解析（重点）" class="headerlink" title="3.dom4j解析（重点）"></a>3.dom4j解析（重点）</h3><h4 id="1-导入dom4j的包"><a href="#1-导入dom4j的包" class="headerlink" title="1.导入dom4j的包"></a>1.导入dom4j的包</h4><h4 id="2-得到document"><a href="#2-得到document" class="headerlink" title="2.得到document"></a>2.得到document</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line"></span><br><span class="line">Document document = reader.read(url);</span><br></pre></td></tr></table></figure><p><em><b>document的父接口是Node</b></em></p><p><b>document方法：</b></p><p>getRootElement:获取根节点，返回为Element，</p><p>Element的父接口也是Node</p><p><em><b>创建解析器</b></em></p><p>得到document</p><p><b>得到根节点</b></p><ul><li><p><b>节点.element（“标签名称”）:</b>得到节点下第一个标签为“标签名称”的节点</p></li><li><p><b>节点.elements（”标签名称”）：</b>得到节点下第一层为“标签名称”的所有节点，为list类型，使用list.get(int)获取是第几个子标签</p></li><li><p><b>节点.element() :</b>得到节点下第一层的所有标签，也是list类型。</p></li><li><p><b>使用getText()</b>方法获得标签中的值</p></li><li><p><b>添加子标签直接使用.addElement()</b>,添加文本直接使用setText().</p></li></ul><p><b>指定位置插入一个标签：</b></p><ul><li><p>主要是调用list中的add（”位置”,”标签的方法”）;</p></li><li><p>所以在某一个复杂元素中插入必须是得到所有的简单元素</p></li><li><p>辅助方法：DocumentHelper.createElement(“标签名称”);<b>来新建一个element</b></p></li></ul><p><b>得到属性值（不需要回写xml）：</b></p><ul><li>标签名称.attributeValue (属性名称)；</li></ul><p><b>回写xml：</b></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OutputFormat format = OutputFormat.createPrettyPrint();//定义xml文件的样式</span><br><span class="line"></span><br><span class="line">XMLWriter xmlWriter = new XMLWriter(new FileOutputStream("src/jaxpText_dom4j_01.xml"),format);//直接new XMLWriter的类传入两个参数第一个文件路径，第二个文件格式</span><br><span class="line"></span><br><span class="line">xmlWriter.write(document);//写入的为document</span><br><span class="line"></span><br><span class="line">xmlWriter.close();//关闭这个流</span><br></pre></td></tr></table></figure><h4 id="3-dom4j对于xpath的支持："><a href="#3-dom4j对于xpath的支持：" class="headerlink" title="3.dom4j对于xpath的支持："></a>3.dom4j对于xpath的支持：</h4><ul><li><p>第一种形式：/aaa /bbb/ccc /表示一层</p></li><li><p>第二种形式：//aaa //表示得到所有的</p></li><li><p>第三种形式：<em> </em>表示得到所有元素</p></li><li><p>第四种形式：/bbb[1] [1]表示第一个元素[last]表示最后一个元素</p></li><li><p>第五中形式：//@属性名称 得到所有含有属性名称的元素</p></li><li><p>第六中形式：//aaa[@属性名称=“值”] 表示名称为bbb并且属性名称为这个值得元素</p></li></ul><h4 id="4-dom4j对于xpach的操作"><a href="#4-dom4j对于xpach的操作" class="headerlink" title="4.dom4j对于xpach的操作"></a>4.dom4j对于xpach的操作</h4><p><b>selectNodes(“xpath语句”)：</b>获取多个节点</p><p><b>selectSingleNode(“xpath语句”):<b>获取单个节点</b></b></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Xml基础知识&quot;&gt;&lt;a href=&quot;#Xml基础知识&quot; class=&quot;headerlink&quot; title=&quot;Xml基础知识&quot;&gt;&lt;/a&gt;Xml基础知识&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;写在前面:今天有时间就把以前学习JavaEE的时候记录的笔记总结了一下。&lt;br&gt;  主要包含XMl的基础和解析技术。&lt;br&gt;
    
    </summary>
    
      <category term="基础" scheme="http://simonxin.top/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础" scheme="http://simonxin.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Java" scheme="http://simonxin.top/tags/Java/"/>
    
      <category term="XML" scheme="http://simonxin.top/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>GitHub代码提交过程</title>
    <link href="http://simonxin.top/2016/11/07/%E5%8E%9F-GitHub%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%BF%87%E7%A8%8B/"/>
    <id>http://simonxin.top/2016/11/07/原-GitHub代码提交过程/</id>
    <published>2016-11-07T05:10:32.000Z</published>
    <updated>2017-05-08T11:15:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GitHub代码提交"><a href="#GitHub代码提交" class="headerlink" title="GitHub代码提交"></a>GitHub代码提交</h2><a id="more"></a><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="http://img.blog.csdn.net/20161107124237507" alt="这里写图片描述"></p><h4 id="Linux系统提交代码过程"><a href="#Linux系统提交代码过程" class="headerlink" title="Linux系统提交代码过程"></a>Linux系统提交代码过程</h4><blockquote><h5 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h5></blockquote><p>安装git环境 <code>sudo apt-get install git-core</code></p><blockquote><h5 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h5></blockquote><p>在github网站创建代码仓库 </p><p><img src="http://img.blog.csdn.net/20161107125311677" alt="这里写图片描述"></p><p>复制Clone地址： </p><p><img src="http://img.blog.csdn.net/20161107125457052" alt="这里写图片描述"></p><blockquote><h5 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h5></blockquote><ul><li><p>进入项目目录<br><img src="http://img.blog.csdn.net/20161107125558118" alt="这里写图片描述"></p></li><li><p>将代码仓库复制到本地<br><font color="red">代码</font><code>git clone xxxxxxxxxxxxxxx</code></p></li></ul><p><img src="http://img.blog.csdn.net/20161107125712474" alt="这里写图片描述"></p><ul><li><p>将代码仓库复制到本地之后，项目目录中就会有复制下来的文件<br><img src="http://img.blog.csdn.net/20161107130206580" alt="这里写图片描述"></p></li><li><p>进入到clone下来的文件夹，将复制下来的<font color="red">.git</font>文件和<font color="red">README.md</font>文件复制到项目目录下</p></li></ul><p><font color="red">代码如下：</font><code>cp -r .git/  /home/wang/桌面/Spring</code></p><p><img src="http://img.blog.csdn.net/20161107130429458" alt="这里写图片描述"></p><p><code>cp -r README.md /home/wang/桌面/Spring</code> </p><p><img src="http://img.blog.csdn.net/20161107130609181" alt="这里写图片描述"></p><ul><li>看一看项目文件夹下是否存在刚刚复制的文件</li><li>删除clone下来的文件<br><code>rm -rf Spring/</code></li></ul><h4 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h4><ul><li><p>将文件添加到git上面<br><code>git add .</code><br><strong>add . 就是讲所有的文件添加</strong></p></li><li><p>添加提交注释<br><code>git commit -m &quot;提交注释&quot;</code><br><strong>”“中就是提交的注释</strong></p></li><li><p>将代码提交到远程版本控制库<br><code>git push origin master</code></p></li><li><p>输入账号和密码<br><img src="http://img.blog.csdn.net/20161107130713041" alt="这里写图片描述"><br>等输入完就提交完了</p></li></ul><p>然后再查看你的github库就发现本地的代码提交上去了 </p><p><img src="http://img.blog.csdn.net/20161107130840775" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;GitHub代码提交&quot;&gt;&lt;a href=&quot;#GitHub代码提交&quot; class=&quot;headerlink&quot; title=&quot;GitHub代码提交&quot;&gt;&lt;/a&gt;GitHub代码提交&lt;/h2&gt;
    
    </summary>
    
      <category term="GitHub	" scheme="http://simonxin.top/categories/GitHub/"/>
    
    
      <category term="GitHub" scheme="http://simonxin.top/tags/GitHub/"/>
    
      <category term="经验" scheme="http://simonxin.top/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>java中IO流的操作</title>
    <link href="http://simonxin.top/2016/10/31/%E5%8E%9F-java%E4%B8%ADIO%E6%B5%81%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <id>http://simonxin.top/2016/10/31/原-java中IO流的操作/</id>
    <published>2016-10-31T13:49:27.000Z</published>
    <updated>2017-05-08T11:15:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Io流操作"><a href="#Io流操作" class="headerlink" title="Io流操作"></a>Io流操作</h1><p>File file = new File(“文件路径”)<br>file.exists:文件是否存在<br>file.createNewFile:创建新的文件<br>file.delete:删除文件<br><a id="more"></a><br>file.getParent:返回父目录<br>file.makedir:创建目录<br>file.isDirectory:判断文件是不是目录<br>file.list()：返回目录下所有目录包括文件的名称<br>file.listFiles()：返回子目录下所有的文件<br>输入流InputStream<br>in.read(byte[] byte);直接将读入的放在byte中去<br>int.write(byte[] byte,int start ,int size):字节数据byte从start位置开始读size长度的字节到流<br>输出流OutSteam<br>out.write(byte[] byte):将byte自己数据直接写入到流<br>out.write(byte[] byte,int start ,int size):字节数据byte从start位置开始写size长度的字节到流<br>FileInputStream：将文件作为字节流，进行读的操作！<br>通常利用文件缓冲进行文件的读取，用来提高读取大文件的效率<br>FileOutputStream：实现向文件写出字节数据的方法<br>DataOututStream/DataInputStream<br>对“流”功能的拓展，可以更加方便的读取int，long，字符等类型数据<br>不再是只读字节的前八位<br>DataOutStream out = new DataOutStream(new FileOutStream(file));<br>DataInpuyStream in = new DataIntStream(new FileInputStream(file));<br>BufferedInputStream/BufferedOutputStream<br>这两个流为IO提供带缓冲区的操作，一般打开文件进行写入或者读取时，都会加上缓冲，这种流模式提高了IO的性能。<br>FileOutStream—&gt;write()方法相当于将一滴滴的”水“转移到”缸“中<br>DataOutStream—&gt;write()方法相当于一瓢瓢地把“水”放到“缸”中<br>BufferedOutStream—&gt;write()方法相当于先一瓢瓢地把“水”方法到“桶”中去，然后再放到”缸“中去<br>字符流(默认按照项目编码来读写的)：<br>InputStreamReader :完成byte流解析为char流<br>OutputStreamWrite :提供char流到byte流的解析</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Io流操作&quot;&gt;&lt;a href=&quot;#Io流操作&quot; class=&quot;headerlink&quot; title=&quot;Io流操作&quot;&gt;&lt;/a&gt;Io流操作&lt;/h1&gt;&lt;p&gt;File file = new File(“文件路径”)&lt;br&gt;file.exists:文件是否存在&lt;br&gt;file.createNewFile:创建新的文件&lt;br&gt;file.delete:删除文件&lt;br&gt;
    
    </summary>
    
      <category term="基础" scheme="http://simonxin.top/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础" scheme="http://simonxin.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Java" scheme="http://simonxin.top/tags/Java/"/>
    
      <category term="Io流" scheme="http://simonxin.top/tags/Io%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>BadgeView开源项目的使用.md</title>
    <link href="http://simonxin.top/2016/10/17/%E5%8E%9F-BadgeView%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%BD%BF%E7%94%A8-md/"/>
    <id>http://simonxin.top/2016/10/17/原-BadgeView开源项目的使用-md/</id>
    <published>2016-10-17T12:35:49.000Z</published>
    <updated>2017-05-08T11:15:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><font color="red" size="5">BadgeView开源项目的使用</font><br><a id="more"></a></p><h2 id="第一步：导入jar包"><a href="#第一步：导入jar包" class="headerlink" title="第一步：导入jar包"></a>第一步：导入jar包</h2><pre><code>badgeview.jar</code></pre><h2 id="第二步：初始化BadgeView"><a href="#第二步：初始化BadgeView" class="headerlink" title="第二步：初始化BadgeView"></a>第二步：初始化BadgeView</h2><pre><code>Private BadgeView badgeView; protected void onCreate(Bundle savedInstanceState) {   super.onCreate(savedInstanceState);   badgeView = new BadgeView(getApplicationContext()); }</code></pre><h2 id="第三步：设置BadgeView的属性"><a href="#第三步：设置BadgeView的属性" class="headerlink" title="第三步：设置BadgeView的属性"></a>第三步：设置BadgeView的属性</h2><ul><li><p>设置小红点中显示的数量</p><p><code>badgeView.setBadgeCount(int)；</code></p></li><li><p>设置小红点是附着在那个View上面<br><code>badgerView.setTargetView(TargetView);</code></p></li><li><p>设置所处小红点的位置<br><code>setBadgeGravity(Gravity)</code></p></li><li><p>设置小红点的背景颜色<br><code>setBackgroundColor()</code></p></li><li><p>设置小红点的背景图片<br><code>setBackgroundResource()</code></p></li><li><p>设置字体的阴影<br><code>setShadowLayer()</code></p></li><li><p>设置显示的字体<br><code>setTypeface()</code></p></li></ul><h2 id="效果演示："><a href="#效果演示：" class="headerlink" title="效果演示："></a>效果演示：</h2><p><img src="http://img.blog.csdn.net/20161017203510198" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font color=&quot;red&quot; size=&quot;5&quot;&gt;BadgeView开源项目的使用&lt;/font&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://simonxin.top/categories/Android/"/>
    
    
      <category term="Android" scheme="http://simonxin.top/tags/Android/"/>
    
      <category term="框架" scheme="http://simonxin.top/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>第一个Android Demo :Chat(伪即时通讯)</title>
    <link href="http://simonxin.top/2016/05/30/%E5%8E%9F-%E7%AC%AC%E4%B8%80%E4%B8%AAAndroid-Demo-Chat-%E4%BC%AA%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF/"/>
    <id>http://simonxin.top/2016/05/30/原-第一个Android-Demo-Chat-伪即时通讯/</id>
    <published>2016-05-30T08:15:53.000Z</published>
    <updated>2017-05-08T11:15:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>说明</strong>：上一篇文章因为我对这个写博客还不是很了解，所以造成了页面很乱的情况，所以看到之后马上修改</p><p>学习Android到现在估计应该还不到一个月的时间，我很激动能够在自己的努力还有奋斗下开发一个自己想要的App,虽然这个App的功能还不够完善，界面很丑陋，Bug很存在很多，但是我觉得这个起码是我自己动用智慧开发的第一个App,所以我要在这里将我开发的思路还有一个想法写在这里。<br><a id="more"></a><br>以实现功能：<br>即时通讯：不同好友之间可以即时通讯。但是同时只能和一个人通讯。<br>注   册：注册功能实现，但是数据保存的是客户端，即是在Android本地的数据库，并没有将用户保存到服<br>服务器。<br>登   录：登录会自动和本地数据库中进行校对,基本的登录思想。<br>添加好友：当前数据库中存在好友时，可以实现添加到好友列表。Bug：Sqlite的用法还是不够熟练，<br>当存在该好友的情况下还是可以继续添加该还有</p><p>用到的知识：<br>基本的Android界面布局，Sqlite，Servlet（服务器端），JavaBean思想，Http协议，Android中的<br>Http操作，ListView，自定义ArrayAdapter,Android中Activity的生命周期，Activity中的定时操<br>作，异步处理，子线程处理。</p><pre><code>功能详解：Login（登录页面）：</code></pre><p><img src="http://img.blog.csdn.net/20160527124853791?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="这里写图片描述"><br>    作为App的主页面，虽然丑陋了一点，但是它起到的作用也就是仅仅登录作用，当点击登录之后，会自动<br>    和本地数据库中做校验，存在即登录，失败即提示无法登陆；<br>    <img src="http://img.blog.csdn.net/20160527125415498?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="这里写图片描述"></p><pre><code>Regist(注册页面)：和登录洗洗相关的，登录即少不了注册;</code></pre><p><img src="http://img.blog.csdn.net/20160530162332841?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="这里写图片描述"><br>这个是我注册的主界面，提供了用户名，密码注册选项，其中后台数据库并没有使用Base64,和md5进行加密。<br>其中在后台会自动为每一个UUID作为主键，保证每个人的信息不同，其中用户名时唯一存在的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;).toUpperCase();</span><br></pre></td></tr></table></figure><p>当数据库存在该用户时：<br><img src="http://img.blog.csdn.net/20160530163011536" alt="这里写图片描述"><br>数据库中保存的情况：</p><p><img src="http://img.blog.csdn.net/20160530163220229" alt="这里写图片描述"></p><p>FriendList(好友列表)：</p><p><img src="http://img.blog.csdn.net/20160530163420366" alt="这里写图片描述"><br>此处是用来显示自己的好友；还提供添加好友的按钮和逻辑<br>实现思想：创建一个JavaBean,包含当前用户和用户所有的好友List<friend>，并在数据库中创建相关的表。<br>当接收从登陆界面获得的User时，用得到的User和数据库中的当前用户做比较，返回所有的List<friend>。</friend></friend></p><p>复写：ArrayAdapter，添加选中事件。</p><p>AddFriend(添加好友页面):</p><p><img src="http://img.blog.csdn.net/20160530163923744" alt="这里写图片描述"><br>输入需要查找的好友；如果存在：</p><p><img src="http://img.blog.csdn.net/20160530163929338" alt="这里写图片描述"><br>找到该好友并且提供添加。</p><p><img src="http://img.blog.csdn.net/20160530163933800" alt="这里写图片描述"><br>点击OK之后会在数据中将该好友的信息添加到该用户的好友列表中去。</p><p>但是当不存在时，会提示不存在该好友。</p><p>已知Bug:<br>由于对Sqlite的使用不是很熟练,导致不能判断在该用户的好友列表是否已经存在该好友，导致可以重复添加单个用户。</p><p>Chat(聊天)：<br>这个应该才是重点。<br>基本界面：</p><p><img src="http://img.blog.csdn.net/20160530164433387" alt="这里写图片描述"></p><p>很简陋的一个页面。当点击了该还有之后便可以实现好友之间的通讯。</p><p>演示图：</p><p><img src="http://img.blog.csdn.net/20160530164940798" alt="这里写图片描述"></p><p>基本思想：使用的是Http协议进行通讯，后台是使用Servlet写的。</p><p>发送消息：每个用户进行发消息，会将当前的消息内容，当前用户，目的用户发送到后台的Servlet。后台接受到所有用户发送的消息，保存到一个Bean类中去。</p><p>接受消息：在MainActivity创建一个定时操作。一直访问后台的Servlet。后台通过访问接受到数据进行分辨，将该用户的信息返回。（为了研究那个定时操作，我用掉了手机100多M流量）;</p><p>因为学过一段时间的JavaWab所以还是有一点点后台基础的。。。</p><p>好了 我这个第一个AndroidDemo Chat在这里也介绍完了。希望Csdn中的大牛能够指出我的错误和不足的地方，我好进步。</p><p>写完这个博客我很激动，毕竟这个是我第一Android项目，并且也是第一个技术贴。我很懒不是很喜欢打那么多字，但是这个博客慢慢的就写完了。。。</p><p>分享下自己下段时间的打算：</p><pre><code>Android生命周期的更深层次理解Android动画相关知识Android基本手势操作JavaIo流的复习和深入</code></pre><p><strong>*</strong>虽然我现在还是个菜鸟，但是我相信我还是可以飞的！！！！！！！！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：上一篇文章因为我对这个写博客还不是很了解，所以造成了页面很乱的情况，所以看到之后马上修改&lt;/p&gt;
&lt;p&gt;学习Android到现在估计应该还不到一个月的时间，我很激动能够在自己的努力还有奋斗下开发一个自己想要的App,虽然这个App的功能还不够完善，界面很丑陋，Bug很存在很多，但是我觉得这个起码是我自己动用智慧开发的第一个App,所以我要在这里将我开发的思路还有一个想法写在这里。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://simonxin.top/categories/Android/"/>
    
    
      <category term="Android" scheme="http://simonxin.top/tags/Android/"/>
    
      <category term="Java" scheme="http://simonxin.top/tags/Java/"/>
    
      <category term="开发" scheme="http://simonxin.top/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>路在远方，努力不止！！！</title>
    <link href="http://simonxin.top/2016/05/13/%E5%8E%9F-%E8%B7%AF%E5%9C%A8%E8%BF%9C%E6%96%B9%EF%BC%8C%E5%8A%AA%E5%8A%9B%E4%B8%8D%E6%AD%A2%EF%BC%81%EF%BC%81%EF%BC%81/"/>
    <id>http://simonxin.top/2016/05/13/原-路在远方，努力不止！！！/</id>
    <published>2016-05-13T04:15:01.000Z</published>
    <updated>2017-05-08T11:15:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><span style="color:#ff6666">写给自己：<span style="white-space:pre"> </span>作为一个理科生，我认为我自己很难写出那种感动人的文字和带着浓厚笔墨味文章，所以我只是想在这里默默的发布者我自学Android的学习心得。</span><br><a id="more"></a></p><p>大二下的我还在迷茫，大一上加入实验室C语言，对如刚刚上大学的我来说大学太好玩了，没有高中的约束没有作业，有很多很多的时间可以去打游戏可以不用去想哪一些烦心的事情，所以我虽然在实验室，但是贪玩的我很少待在哪里，C语言惨败。大一下，我在学长的指导下自学了C#那时候的我很勤奋，有时间就劲量待在哪里，我觉得大一下的生活很充实，我学到了很多东西，也觉得时间过得好慢，每天都是满满的，虽然周末也是去打游戏，但是我起码花费了时间在学习上面。大二上对我来说是惨淡的，现在想起来我都不知道我的大二上到底是干了什么。。每天待在宿舍的打游戏打游戏打游戏，期末没有复习玩玩玩，果然我迎来了大学的第一次挂科并且还是一次挂了两科！！可怕。现在想起来对如那时候的回忆一点也没有。只知道LOL还有睡觉。可能是上天也看不下去我整天的打游戏了吧。希望我好好努力来扛起我加的重担。虽然大二下到现在才两个多月但是我觉得我每天都是满满的，除了晚上睡觉我要不是在实验室学习就是在上课。一个多月我学完了javaEE虽然不是很精通，也没有和他们一起做过任何项目，但是我觉得能过多学一点起码是有一点谈资的。我开始准备是这个学期学习wab下个学期在去学习Android但是我觉得留给我的时间不多了。第一本书就是看了好多帖子说的&lt;第一行代码&gt;。我差不多花了半个月看完的吧，索然看的不是很清楚，但是我准备再看一遍。<span style="color:#ff0000">所以我还在路上，朝着生活追赶！！！</span></p><p><span style="color:#ff6666"></span></p><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;span style=&quot;color:#ff6666&quot;&gt;写给自己：&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;作为一个理科生，我认为我自己很难写出那种感动人的文字和带着浓厚笔墨味文章，所以我只是想在这里默默的发布者我自学Android的学习心得。&lt;/span&gt;&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="http://simonxin.top/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="http://simonxin.top/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="生活" scheme="http://simonxin.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="反思" scheme="http://simonxin.top/tags/%E5%8F%8D%E6%80%9D/"/>
    
  </entry>
  
</feed>
